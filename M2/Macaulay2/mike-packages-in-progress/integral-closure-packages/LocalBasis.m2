--needsPackage "TowerRings"
debug Core

newPackage(
        "LocalBasis",
        Version => "0.1", 
        Date => "2 Jun 2010",
        Authors => {{Name => "Mike Stillman", 
                  Email => "mike@math.cornell.edu", 
                  HomePage => "http://www.math.cornell.edu/~mike"}},
        Headline => "local integral bases in small characteristic, for plane curves",
        PackageImports => {"UPolynomials", "TowerRings"},
        PackageExports => {"FractionalIdeals"},
        DebuggingMode => true
        )

export {
     "localBasis", 
     "localBases", 
     "companionMatrix", 
     "traceMap", 
     "Start", 
     "Multiplicity", 
     "PrintLevel",
     "integralBasis", 
     "ringFromFracs", 
     "FullBasis", 
     "combineBases"
     }

PartialBasis = new Type of List
toFullBasisOld = (B,n,R) -> (
    y := R_0;
    H := new MutableList from toList (n:null);
    for b in B do H#(degree_y b#1) = b;
    H#0 = {0, 1_R};
    for i from 1 to n-1 do (
        if H#i === null then (
            old := H#(i-1);
            H#i = {old#0, y*old#1};
            );
        );
    new List from H
    )
toFullBasis = (B,n,gx) -> (
    R := ring gx;
    y := R_0;
    H := new MutableList from toList (n:null);
    for b in B do H#(degree_y b#1) = {b#1, {{gx,b#0}}};
    H#0 = {1_R, {}};
    for i from 1 to n-1 do (
        if H#i === null then (
            old := H#(i-1);
            H#i = {y*old#0, old#1};
            );
        );
    new PartialBasis from H
    )
net PartialBasis := (B) -> (
    for b in B list (
        if #b#1 === 0 then 
          b#0 
        else (
            powers := b#1/(e -> new Power from {e#0, e#1});
            new Divide from {b#0, product powers}
            )
        )
    )
value PartialBasis := (B) -> (
    v := net B;
    v/value
    )
ring PartialBasis := (B) -> ring B#0#0
combineBases = method()
combineBases(PartialBasis, PartialBasis) := (B1, B2) -> (
    if #B1 =!= #B2 then error "bases have different sizes";
    R := ring B1;
    if R =!= ring B2 then error "bases are over different rings";
    new PartialBasis from 
      for i from 0 to #B1-1 list (
        -- gcdCoefficients of the denominators, in a ring kk[x].
        -- then combine the numerators together
        -- TODO: NOT DONE (in middle of routine, Jan 30).
        )
    )

debug Core
--needsPackage "TowerRings"
factorize = method()
factorize RingElement := (F) -> (
     facs := factor F;
     facs//toList/toList/reverse
     )

-- The internal functions here expect that the polynomial ring is
-- S = kk[y,x,MonomialOrder=>{1,1}], or kk[y,x,MonomialOrder=>Lex] 
--   (with possibly different names for variables)
-- R = S/F
-- S_1 is the independent variable, and F should be monic in S_0.
-- Functions assuming this include:
--  CtoB, BtoC
--  kerEqns, step3, localBasis1

-- We have two representations of a partial (local) integral basis.
-- MAIN representation, used as output
-- B = {{d1,b1(x,y)}, ..., {dr,br(x,y)}
-- where:
--   (a) 1 <= d1 < d2 < ... < dr
--   (b) if e_i = degree_y bi(x,y), then 1 <= e1 < ..., er < deg_y(F).
--   (c) bi(x,y) is monic in y
--   (d) bi(x,y)/x^di is integral
-- We also assume that frobenius(L(B)) is contained in L(B).
--
-- SECONDARY REP, used in algorithm:
-- C is a list {x^D, b1(y,x), ..., b_(n-1)(y,x)}
--  where: bi(y,x) = x^d * y^i + lower terms in y

CtoB = (C) -> (
     -- C is a list {x^D, b1(y,x), ..., br(y,x)}
     --  the ring needs to be either Lex y > x, or 2 blocks: kk[y,x, MonomialOrder=>{1,1}]
     -- output: B = (degs, Bs)
     --   where:
     --     degs: list of {0, i1, , ..., ik}
     --     Bs: polys, monic in y, length k
     --   such that the kk[x]-module generated by 1/x^D*C is L(B)
     R := ring C#0;
     x := R_1;
     C1 := apply(C, f -> join(first exponents leadTerm f, {f}));
     transpose for i from 1 to #C1-1 list (
     	  d := C1#(i-1)#1 - C1#i#1;
     	  if d > 0 then (
	       {C1#0#1 - C1#i#1, C1#i#2 // x^(C1#i#1)}
	       )
     	  else continue
	  )
     )

BtoC = (B,R) -> (
     -- R should be kk[y,x,MonomialOrder=>{1,1}/F
     -- B is as described above
     y := R_0;
     x := R_1;
     F := (ideal R)_0;
     S := ring F;
     n := degree_(S_0)(F);
     C := new MutableList from n:null;
     D := if #B == 0 then 0 else (last B)_0;
     C#0 = x^D;
     for b in B do (
	  dx := D - b#0;
	  dy := degree(y, b#1);
	  C#dy = x^dx * b#1;
	  );
     for i from 1 to n-1 do 
       if C#i === null then
         C#i = y*C#(i-1);
     toList C
     )

-- given a set of generators of a v.s. V in 1/x * L(B),
-- compute {a in V : frob(a) is in V} \subset V
-- 1/x L(B) should be given as x^-D * J, where J is an ideal
-- assumption: frob(L(B)) \subset L(B).
kerEqns = (d,e,C,M) -> (
     -- sub vector space of C (subideal)
     --  such that frob(1/x^d C) \subset 1/x^(d+e) C
     R := ring C#0;
     kk := coefficientRing R;
     q := kk.order;
     p := char kk;
     x := R_1;
     J := x^(d*p-d-e) * (ideal C + x*ideal M);
     RJ := R/J;
     Cp := for c in C list(
	  d := promote(c,RJ);
	  d = d^p;
	  lift(d,R)
	  );
     cfs := sub(last coefficients matrix {Cp}, kk);
     m := gens gb syz cfs;
     if q =!= p then (
	  qp := q//p;
	  -- we replace each element a of m with a^(q/p)
	  m0 := entries m;
	  m1 := apply(m0, c -> apply(c, a -> a^qp));
	  m = matrix m1;
	  );
     D := first entries (matrix{C} * m);
     D
     )

step3 = (C,d) -> (
     C1 := kerEqns(d,0,C,{0_(ring C#0)});
     --<< "step3 " << C1 << endl;
     C0 := C;
     while #C1 > 0 and #C1 < #C0 do (
	  C0 = C1;
	  C1 = kerEqns(d,0,C0,C);
      --<< "step3 " << C1 << endl;
	  );
     C1
     )

localBasis1 = method(Options=>{Start=>{}, PrintLevel=>0, FullBasis=>false})
localBasis1 Ring := opts -> (R) -> (
     F := (ideal R)_0;
     p := char R;
     y1 := (ring F)_0;
     x := R_1;
     y := R_0;
     n := degree_y1 F;
     C := BtoC(opts.Start, R);
     deg := 0;
     -- now loop, modifying C and deg, until no new equations
     while (     
	  D := kerEqns(deg+1,-1,C,{0_R});
	  #D > 0) do (

    --<< "step1" << D << endl;
	  C = new MutableList from for c in C list x*c;
	  for d in D do (a := degree_y(d); C#a = d);
	  C = toList C;

	  deg = deg + 1;
	  );
     -- at this point, C contains the step1 part of the local basis
     --<< "about to enter step3" << endl;
     Cnew := step3(C, deg+1);
     
     if #Cnew > 0 then (
	  C1 := new MutableList from x*C;
	  for c in Cnew do (
	       a := degree_y(c);
	       C1#a = c;
	       );
	  C = toList C1;

	  -- auto-reduce the elements
	  Cm := matrix{C};
	  mons := reverse flatten entries monomials Cm;
	  moncfs := coefficients(Cm, Monomials=>mons);
	  C = flatten entries((first moncfs) * (gens gb last moncfs));
	  );
     transpose CtoB C)


localBasis1(RingElement) := opts -> (F) -> (
     -- This is an internal routine, where F is already in a ring k[y,x,MonomialOrder=>{1,1}]
     -- and k might be an extension ring.
     -- The local basis at x=0 is determined
     -- This routine is usually only called in the case when F has a singularity above x=0,
     -- so the answer should NOT be {}.  However, the function does handle this case.
     R := ring F;
     A := R/F;
     newStart := apply(opts.Start, b -> {b#0, sub(b#1, A)});
     res := localBasis1(A, Start=>newStart);
     B := apply(res, z -> {z#0, sub(z#1, R)});
     if opts.FullBasis then
         toFullBasis(B, degree(R_0, F), R_1)
     else
         B
     )

singSplit = (G0,G1) -> (
     -- G0, G1: elements of a tower ring in 1 free variables
     -- output: list of {e, g, f}
     --  where all of the g and f in all triples are squarefree and relatively prime (possibly = 1_T)
     --  and G0 = product over all triples of g^e * f^e
     --  and the original equation is singular along g=0, but nonsingular along f=0
     T := ring G0;
     S1 := squareFreeDecomposition raw G0;
     splitc := apply(S1, t -> (
	       if t#0 == 1 
	       then {t#0, raw(1_T), t#1} 
	       else (g1 := rawGCD(t#1, raw G1); {t#0, g1, t#1 // g1})));
     splitc)

ramificationInfo = method()
ramificationInfo(List, RawRingElement, RawRingElement) := (Ss, G0, G1) -> (
     p := rawCharacteristic ring G0;
     Es := apply(Ss, x -> {x#0, rawDegree(0,x#1), rawDegree(0,x#2)});
     singmult := sum(Es, x -> x#0 * x#1);
     nonsingmult := sum(Es, x -> x#0 * x#2);
     ldelta := sum(Es, x -> x#1);
     ldiff := sum(Es, x -> (x#0 - 1) * x#2);
     << "nonsingular points: mult (npoints) " << nonsingmult << endl;  -- 2 (deg 3) + 5 (deg 7) + 12 (deg 4)
     << "  tame: ";
       for x in Es do if x#2 > 0 and x#0 % p != 0 then << x#0 << "(" << x#2 << ") ";
     << endl;
     << "  wild: ";
       for x in Es do if x#2 > 0 and x#0 % p == 0 then (
	     ldiff = ldiff + x#2;
	     << x#0 << "(" << x#2 << ") ";
	     );
       << endl;
     << "singular points: mult (npoints) " << singmult << endl << "  ";
       for x in Es do if x#1 > 0 then << x#0 << "(" << x#1 << ") ";
       << endl;
     << "lower bound for delta: " << ldelta << endl;
     << "lower bound on different: " << ldiff << endl;
     --error "look at me ramif";
     Ss
     )

protect symbol DONE
protect symbol NOTDONE

analyzeSingularities = (G,multDisc,toT,fromT,printlevel) -> (
     -- input: G(y,x) in the ring R, about x=0
     --        toT: R --> T  map to the tower ring
     --        fromT: T --> R the map back.
     -- output:
     --        
     R := ring G;
     G0 := toT G;  -- sets X to 0
     G1 := toT diff(R_1, G); -- coeff of X in G
     Ss := singSplit(G0, G1);
     if printlevel > 0 then ramificationInfo(Ss, raw G0, raw G1);
     -- this contains enough information to determine singularity info
     Es := apply(Ss, x -> {x#0, rawDegree(0,x#1), rawDegree(0,x#2)});
     singmult := sum(Es, x -> x#0 * x#1);
     nonsingmult := sum(Es, x -> x#0 * x#2);
     ldelta := sum(Es, x -> x#1);
     ldiff := sum(Es, x -> (x#0 - 1) * x#2);
     if printlevel > 1 then (
	  << netList Es << endl;
	  << netList Ss << endl;
	  if multDisc >= 0 then
	    << "remaining number of powers of g(x) in denominator: " << (multDisc - 2*ldelta - ldiff)//2 << endl;
	  );
     -- NOTE: so far wild ramification is not considered
     if singmult == 0 then return (DONE, {}); -- answer is: no new integral elements
     -- At this point, we know an integral element
     H := raw G0;
     for z in Ss do (c := z#1; if rawDegree(0,c) > 0 then H = H // c);
     H = new ring G0 from H; -- raw element to RingElement
     B := {{1,fromT H}};
     --error "look at me";
     newB := if multDisc >= 0 and multDisc - 2*ldelta - ldiff <= 1 then (DONE, B) else (NOTDONE, B)
     )

localBasis = method(Options => {Multiplicity=>-1,PrintLevel=>0}) -- mult of discriminant
localBasisDegreeOne = method(Options => options localBasis)
localBasisDegreeOne(RingElement, RingElement) := opts -> (F, gx) -> (
     -- Input:
     --  F = poly in two variables x,y.
     --  gx is a monic polynomial of degree one, in one of the variables: gx = x-c
     -- Output:
     --  a local basis B = {{d1,b1(y,x)}, ..., {dr,br(y,x)}}
     --  where (a) each bi is monic of degree i in y,
     --        (b) 0 < d1 < ... < dr
     --        (c) bi/gx^(di) is integral over (ring F)/F.
     -- Optional inputs:
     --  Multiplicity: multiplicity of the factor gx in the discriminant of F
     --  PrintLevel: how much info to see during computation, 0 is silent.
     -- Action:
     --  1. transfer to a ring kk[Y,X], so that gx goes to X.
     --  2. do ramification check to see if we can stop right away.
     --     if not, at least we can start with a better B.
     --  3. if we need to, call localBasis1
     --  4. transfer answer to original ring
     setup := () -> (
     	  origR := ring F;
     	  kk := coefficientRing origR;
     	  if ring gx =!= origR then error "expected same ring";
     	  supp := support gx;
     	  if #supp =!= 1 then error "expected second argument to be a poly in one variable";
     	  x := supp#0;
     	  nonsupp := toList(set gens origR - set supp);
     	  if #nonsupp =!= 1 then error "expected two variables in the ring";
     	  y := nonsupp#0;
     	  xi := index x;
     	  yi := index y;
     	  p := char kk;
     	  X := local X;
     	  Y := local Y;
     	  R := kk[Y, X, MonomialOrder=>{1,1}];
     	  c := lift(x % gx, kk);
     	  toR := map(R, origR, {origR_xi => R_1 + c, origR_yi => R_0});
     	  G := toR F;
	  if toR gx != R_1 then error ("expected monic polynomial: " | toString gx);
	  -- now make the tower ring
	  T := towerRing(kk, 1:Y);  -- WARNING: once we allow kk to be a non-prime finite field, we need to fix this.
	  toT := map(T,R,{R_0 => T_0, R_1 => 0_T}); -- X => 0, Y => Y
	  fromT := map(R,T,{R_0}); -- Y => Y
	  toOrig := map(origR, R, {R_0 => y, R_1 => x - c});
	  (G, toT, fromT, toOrig));
     (G,toT,fromT,toOrig) := setup();
     if opts.PrintLevel >= 1 then << "--- considering discriminant factor (mult = " << opts.Multiplicity << "): " << gx << "---" << endl;     
     (doneflag, startB) := analyzeSingularities(G,opts.Multiplicity,toT,fromT,opts.PrintLevel);
     << "analyzeSingularities returns " << (doneflag, startB) << endl;
     B := if doneflag === DONE then startB else localBasis1(G, Start => startB);
     apply(B, db -> new Divide from {toOrig db#1, new Power from {gx, db#0}})
     )

localBasisDegreeN = method(Options => options localBasis)
localBasisDegreeN(RingElement, RingElement) := opts -> (F, gx) -> (
     -- Input:
     --  F = poly in two variables x,y.
     --  gx is a monic polynomial of degree > 1, in one of the variables: gx(x)
     -- Output:
     --  a local basis B = {{d1,b1(y,x)}, ..., {dr,br(y,x)}}
     --  where (a) each bi is monic of degree i in y,
     --        (b) 0 < d1 < ... < dr
     --        (c) bi/gx^(di) is integral over (ring F)/F.
     -- Optional inputs:
     --  Multiplicity: multiplicity of the factor gx in the discriminant of F
     --  PrintLevel: how much info to see during computation, 0 is silent.
     -- Action:
     --  1. transfer to a ring kk[Y,X], so that gx goes to X.
     --  2. do ramification check to see if we can stop right away.
     --     if not, at least we can start with a better B.
     --  3. if we need to, call localBasis1
     --  4. transfer answer to original ring
     setup := () -> (
     	  origR := ring F;
     	  kk := coefficientRing origR;
     	  if ring gx =!= origR then error "expected same ring";
     	  supp := support gx;
     	  if #supp =!= 1 then error "expected second argument to be a poly in one variable";
     	  x := supp#0;
     	  nonsupp := toList(set gens origR - set supp);
     	  if #nonsupp =!= 1 then error "expected two variables in the ring";
     	  y := nonsupp#0;
     	  xi := index x;
     	  yi := index y;
     	  p := char kk;
     	  X := local X;
     	  Y := local Y;
          -- Now we add in a root a s.t. g(a) = 0, and consider F' = F(x+a,y)
	  a := local a;
     	  A := kk (monoid [a]);
     	  ga := sub(gx, {x=>A_0, y=>0_A});
     	  B := toField(A/ga);
       	    n := first degree ga;
       	    B.order = (kk.order)^n;
     	  R1 := kk(monoid [Y,X, MonomialOrder=>{1,1}]);
     	  R := B (monoid R1);
	  toR := map(R, origR, {origR_xi => R_1 + B_0, origR_yi => R_0});
     	  G := toR F;
	  toOrig := map(origR, R1, {origR_yi, origR_xi});
	  -- now make the tower ring and maps to/from it.  This is currently
	  -- just used to analyze the points of ramification
	  T0 := towerRing(kk, (symbol a, Y));
	  toT0 := map(T0, A, {T0_0});
	  T := T0/(toT0 ga);
	  toT := map(T,R,{T_1, 0_T, T_0}); -- X => 0, Y => Y
	  fromT := map(R,T,{B_0, R_0}); -- Y => Y
	  -- now make the trace map back
	  --  this map is a composite:
	  --  the map takes as input: (d,a,b)  (thought of as b/(x-a)^d, in the ring R)
	  --   1. it multiplies this by c and Qxy, cominging from traceMap
	  --   2. it applies to this the map x --> x - a, y fixed
	  --   3. take the trace, obtaining an element in R1
	  --   4. now make this element monic, by taking a suitable gcd mix.
	  --   5. finally, map back to origR
	  -- the output is a triple (d, gx, f(y,x)), with f monic in y,
	  --  representing the fraction f(y,x)/gx^d
	  RtoR := map(R, R, {R_0 => R_0, R_1 => R_1 - B_0}); -- map back in step (2)
	  gR1 := sub(gx, {x => R1_1, y => R1_0});
     	  (trRR1, c, Qxy) := traceMap(R,R1); --we will apply this as: trR'R''(c * elem * Qxy^i)
	  --traceDeg1 := map(R1,R,{R1_0, R1_1, R1_1});  -- this avoids trace if the denom degree is 1.
	  traceDeg1 := map(origR,R,{origR_yi, origR_xi, origR_xi});  -- this avoids trace if the denom degree is 1.
	  tracer := (i,elem) -> (
	       if i === 1 then 
	           {1, traceDeg1 elem}
	       else (
	           elem2 := RtoR elem;
	           numer := trRR1(c * elem2 * Qxy^i);
	           monicNumer := newMakeMonic(numer, gR1^i);
	           {i, toOrig monicNumer}
	       ));
	  (G, toT, fromT, tracer));
     (G,toT,fromT,tracer) := setup();
     if opts.PrintLevel >= 1 then << "--- considering discriminant factor (mult = " << opts.Multiplicity << "): " << gx << "---" << endl;     
     (doneflag, startB) := analyzeSingularities(G,opts.Multiplicity,toT,fromT,opts.PrintLevel);
     B := if doneflag === DONE then startB else localBasis1(G, Start => startB);
     --error "look at me";
     B = apply(B, z -> tracer(z#0, z#1));
     apply(B, db -> new Divide from {db#1, new Power from {gx, db#0}})
     )

newMakeMonic = (fxy, gx) -> (
     -- input:
     --   fxy = poly in a ring kk[Y,X] = R
     --    gx = poly in the same ring, just involving X (= R_1)
     -- returns:
     -- action:
     --  suppose that h(X) = lead coefficient of highest power of Y in fxy.
     --  and that a(x) h(x) + b(x) g(x) = 1 
     --  then return a(x) * fxy, modulo g(x).
     R := ring fxy;
     kk := coefficientRing R;
     hx := first flatten entries last coefficients(fxy, Variables => {R_0});
     -- make a tower ring
     T := towerRing(kk, 1 : local X);
     toT := map(T,R,{R_0 => 0_T, R_1 => T_0});
     fromT := map(R,T,{R_1});
     (g,u,v) := gcdCoefficients(toT hx, toT gx);
     if g != 1 then << "my logic might be wrong" << endl;
     ((fromT u) * fxy) % gx
     )

checkInputPoly = (F) -> (
     -- Either returns null (everything OK), or signals an error.
     -- things to check here:
     -- R should be of char p, have two variables
     -- F should be monic in the first variable (of positive degree).
     R := ring F;
     if char R === 0 then error "char 0 integral bases not yet implemented";
     if numgens R =!= 2 then error "expected a ring in two variables";
     exps := (exponents F);
     d := max (exps/first);
     dlocs := positions(exps, e -> e#0 === d);
     if d === 0 then error ("expected a polynomial of positive degree in "|toString R_0);
     if #dlocs =!= 1 or exps#(dlocs#0)#1 > 0 then error ("expected a polynomial monic in "|toString R_0);
     )

{*
*************************************************************
---------------------
-- new localBasis function
localBasis(RingElement, RingElement, RingElement) := (F, gx, y) -> (
    -- Input: (a) F is an element in a polynomial ring R in two variables: support gx, and y,
    --            over a field kk, which can be an extension field.
    --        (b) gx: an irreducible polynomial (over kk) in a single variable x.
    --            OR: gx = 1/x, in which case the local basis at infinity is computed
    --        (c) y: a variable in the ring F
    -- Output: a local basis B of kk[x,y]/F, a list of n elements (n = deg_y(F))
    --    of the form { b_i(y,x)/gx^(d_i) }, for i=0..n-1.
    --    where: b_i is monic in y (at least if F is monic in y), and 
    --    the given elements are a k[x]_(g(x)) basis for the integral closure of this ring in kk(x,y).
    -- Begin
    --   if gx = 1/x, then replace F by G = F(1/x, y/x) (else G=F), 
    --                     record that we need to transform back at the end
    --   if G is not monic in y, then 
    --      transform it so that it is.  Recall the transform for the end
    --   if gx is x or is linear in x, then 
    --      transform G to origin, remember transform back
    --   else
    --      extend the field KK to include a root of gx=0
    --      place G into KK[x,y], remember that we need to use traces to go back
    --      transform G so that the center is now x=0 (recall the transform back).
    --   end
    --   
    --   (startB,isDone) := starting partial local basis (checks singularity)
    --   if not isDone then
    --       B := localBasis1(G, startB, x, y)
    --   else
    --       B := startB
    --
    --   B' = if gx is not linear, then 
    --           use traces and/or tricks to change B to a local basis for OO_gx
    --           (transform x --> x+alpha too)
    --        else
    --           transform B back to ring F.
    --
    --   if G was not monic then modify B' accordingly
    --   if gx == 1/x, then modify B' accordingly
    --   return B'
    -- End
    )

localBasis = (F,gx,y,opts) -> (
    -- check arguments
    B := localBasisA(F,gx,y,opts)
    package B as 'Divide's
    )

localBasisA = (F,gx,y,opts) -> (
    -- handle the point at infinity
    if gx == 1/x then 
       G := transform F
       B := localBasisB(G,x,y,opts)
       B' := transform B back
    else
       localBasisB(G,gx,y,opts)
    )

localBasisB = (F,gx,y,opts) -> (
    -- handle case when F is not monic in y
    if F is not monic in y then
       G := transform F
       B := localBasisC(G,x,y,opts)
       B' := transform B back
    else
       localBasisC(G,x,y,opts)
    )

localBasisC = (F,gx,y,opts) -> (
    -- handle extension field case
    if gx is not of degree 1 in x then
        adjoin root to kk
        B := localBasisD(F extended to new ring, x-alpha, y, opts)
        B' := use traces or tricks to drop B to coefficients in kk
    else
        localBasisD(F,gx,y, opts)
    )

localBasisD = (F,gx,y,opts) -> (
    -- move to x=0 if needed
    if gx != x then 
        G := transform F via x -> x+alpha
        B := localBasisE(G, x, y, opts)
        B' := transform B back via inverse transform
    else
        localBasisE(G,x,y, opts)
    )

-- What would this look like as one function? Pretty messy

localBasisMoveOrigin = (fcns, F, gx,y,opts) -> (
    f := fcns#0;
    fcns = drop(fcns,1);
    x := first support gx;
    -- assumptions here: 
    --  gx = linear polynomial in x (even monic?)
    --  y = variable
    --  F is monic in y
    if gx != x then (
        (moveTo, moveFrom) := switchOrigin(gx);
        F1 := moveTo F;
        B := f(fcns, moveTo F, x, y, opts);
        -- now move the factions back
        -- (power, numerator, denominator)
        B/((n,num,denom) -> (n,moveFrom num, gx))
        )
    else
        f (fcns, f, gx, y, opts)
    )

localBasis = (F,gx,y,opts) -> (
    if ring gx === frac ring F then (
        );
    )
*************************************************************
*}

analyzeFiber = (G,multDisc,toT,fromT,printlevel) -> (
     -- input: G(y,x) in the ring R, about x=0
     --        toT: R --> T  map to the tower ring
     --        fromT: T --> R the map back.
     -- output:
     --        
     R := ring G;
     p := char R; -- only used to consider wild ramification
     G0 := toT G;  -- sets X to 0
     G1 := toT contract(R_1, G); -- coeff of X in G
     -- singular points above x=0 are the solutions to G1 = G0 = diff(y,G0) = 0.
     Ss := singSplit(G0, G1);
     -- this contains enough information to determine singularity info
     Es := apply(Ss, x -> {x#0, rawDegree(0,x#1), rawDegree(0,x#2)});
     singmult := sum(Es, x -> x#0 * x#1);
     nonsingmult := sum(Es, x -> x#0 * x#2);
     ldelta := sum(Es, x -> x#1);
     ldiff := sum(Es, x -> (x#0 - 1) * x#2);
     if printlevel > 1 then (
         -- Now we display the various points
         << "#points\tmult\tsing?\tfactor in y" << endl;
         -- first loop through the non-singular points
         for s in Ss do (
             if s#2 != 1 then (
                 << rawDegree(0,s#2) << "\t" -- number of points here is degree of this poly
                 << s#0 << "\t" -- multiplicity of each of these point
                 << "no" << "\t" -- doing non-singular points
                 << s#2 << endl; -- the polynomial
             ));
         for s in Ss do (
             if s#1 != 1 then (
                 << rawDegree(0,s#1) << "\t" -- number of points here is degree of this poly
                 << s#0 << "\t" -- multiplicity of each of these point
                 << "yes" << "\t" -- doing non-singular points
                 << s#1 << endl; -- the polynomial
             ));
	 );
     -- NOTE: so far wild ramification is not considered
     return;
     if singmult == 0 then return (DONE, {}); -- answer is: no new integral elements
     -- At this point, we know an integral element
     H := raw G0;
     for z in Ss do (c := z#1; if rawDegree(0,c) > 0 then H = H // c);
     H = new ring G0 from H; -- raw element to RingElement
     B := {{1,fromT H}};
     --error "look at me";
     newB := if multDisc >= 0 and multDisc - 2*ldelta - ldiff <= 1 then (DONE, B) else (NOTDONE, B)
     )

makeTowerMaps = (R,x,y) -> (
    -- Given a ring kk[y,x] (or kk[x,y]), create
    -- a tower ring T = kk[y], and ring maps
    -- toT: R --> T, which sets x to 0.
    -- and
    -- fromT: T --> R, which sends y to y.
    -- WARNING: currently only defined for kk = ZZ/p, or an extension toField(kk[a]/(g(a))).
    kk := coefficientRing R;
    if char kk == 0 or instance(kk, GaloisField)
    then error "cannot yet handle char 0 or encoded GaloisFields";
    --------------------------------
    -- Create a tower ring.  This depends on whether kk is an extension of ZZ/p or not
    local T;
    local toT;
    local fromT;
    a := local a;
    Y := local Y;
    if kk.order == char kk then (
        T = towerRing(kk, 1:Y);
        toT = map(T,R,{R_0 => T_0, R_1 => 0_T}); -- Y => Y, X => 0
        fromT = map(R,T,{R_0}); -- Y => Y
        )
    else (
        -- WARNING: this code block is FRAGILE!!  FIX THAT!! (10 Dec 2013 MES)
        A := coefficientRing kk; -- the underlying polynomial ring
        ga := (ideal A)_0;
        T0 := towerRing(coefficientRing A, (a, Y));
        toT0 := map(T0, ring ga, {T0_0});
        T = T0/(toT0 ga);
        toT = map(T,R,{T_1, 0_T, T_0}); -- Y => Y, X => 0, a => a
        fromT = map(R,T,{kk_0, R_0}); -- Y => Y
        );
    (toT, fromT)
    )

startSystem = (F,x,y,opts) -> (
    (toT, fromT) := makeTowerMaps(ring F,x,y);
    analyzeFiber(F,opts.Multiplicity,toT,fromT,2);
    analyzeSingularities(F,opts.Multiplicity,toT,fromT,0)
    )

TEST ///
  restart
  debug needsPackage "LocalBasis"
  kk = ZZ/2
  R = kk[y,x, MonomialOrder=>{1,1}]
  P = x^3+x^2+1
  F = y^3*(y-1) + P^2*y + P^3
  factorize discriminant(F,y) -- factor of x^4 in disc
  startSystem(F,x,y,new OptionTable from {Multiplicity=>4, PrintLevel=>2})
  localBasis(F,x,y)

  S = kk[y,x,z, MonomialOrder=>{1,1,1}]
  G = sub(homogenize(sub(F,S), z), x=>1)
  Rx = kk[y,z, MonomialOrder=>{1,1}]
  G = sub(G, Rx)
  G1 = numerator sub(G, y => y/z^2)
  localBasis(G1, z,y)
  G0 = sub(F, {x=>0})

  factor G0
  G1 = sub(contract(x,F), {x=>0})
  V = contract(x^2,F)
  w = (y+1)*(y^2+y+1)/x
  numerator(w^2 + (y^2+y+1)*V) % F
  numerator(w^2) % F
  localBases(F, PrintLevel=>2)
  
  debug LocalBasis
  (toR1, fromR1) = switchCenter(R, last last factorize discriminant(F,y))
  F1 = toR1 F;
  startSystem(F1, (ring F1)_1, (ring F1)_0, new OptionTable from {Multiplicity=>6, PrintLevel=>2})
  
  for fs in factorize discriminant(F,y) list (
      (toR1, fromR1) = switchCenter(R, fs#1);
      F1 = toR1 F;
      startSystem(F1, (ring F1)_1, (ring F1)_0, new OptionTable from {Multiplicity=>fs#0, PrintLevel=>2})
      )
  
///

switchCenter = (origR,gx) -> (
    -- adjoin a root 'a' to kk if needed to get a new ring R1 = B (monoid R), and
    -- then return toNewRing : origR --> R, x -> x+a, y -> y
    --        and  toOld : R --> R  which sends x -> x-a, y -> y.
    kk := coefficientRing origR;
    supp := support gx;
    if #supp != 1 then error "expected center to be a polynomial involving one variable";
    x := supp#0;
    ix := index x;
    x1 := local x1;
    A := kk[x1];
    toA := map(A,origR, for v in gens origR list if v == x then A_0 else 0_A);
    gx1 := toA gx;
    a := adjoinRoot gx1;
    (ring a).order = (char kk)^(degree(x,gx));
    R := (ring a)(monoid origR);
    vars := for i from 0 to numgens R - 1 list (
        if i == ix then R_i + a else R_i
        );
    vars2 := for i from 0 to numgens R - 1 list (
        if i == ix then R_i - a else R_i
        );
    toCenter := map(R,origR,vars);
    fromCenter := map(R,R,vars2); 
    (toCenter,fromCenter)
    )

TEST ///
  restart
  debug needsPackage "LocalBasis"

  kk = ZZ/2
  R = kk[y,x,MonomialOrder=>{1,1}]
  F = (y^21
   +y^20*x
   +y^18*(x^3+x+1)
   +y^17*(x^3+1)
   +y^16*(x^4+x)
   +y^15*(x^7+x^6+x^3+x+1)
   +y^14*x^7
   +y^13*(x^8+x^7+x^6+x^4+x^3+1)
   +y^12*(x^9+x^8+x^4+1)
   +y^11*(x^11+x^9+x^8+x^5+x^4+x^3+x^2)
   +y^10*(x^12+x^9+x^8+x^7+x^5+x^3+x+1)
   +y^9*(x^14+x^13+x^10+x^9+x^8+x^7+x^6+x^3+x^2+1)
   +y^8*(x^13+x^9+x^8+x^6+x^4+x^3+x)
   +y^7*(x^16+x^15+x^13+x^12+x^11+x^7+x^3+x)
   +y^6*(x^17+x^16+x^13+x^9+x^8+x)
   +y^5*(x^17+x^16+x^12+x^7+x^5+x^2+x+1)
   +y^4*(x^19+x^16+x^15+x^12+x^6+x^5+x^3+1)
   +y^3*(x^18+x^15+x^12+x^10+x^9+x^7+x^4+x)
   +y^2*(x^22+x^21+x^20+x^18+x^13+x^12+x^9+x^8+x^7+x^5+x^4+x^3)
   +y*(x^23+x^22+x^20+x^17+x^15+x^14+x^12+x^9)
   +(x^25+x^23+x^19+x^17+x^15+x^13+x^11+x^5))
elapsedTime  discs = select(factorize discriminant(F,y), f -> # support(f#1) == 1);  -- remove constant terms

  for fs in {discs#3} list (
      (toR1, fromR1) = switchCenter(R, fs#1);
      F1 = toR1 F;
      startSystem(F1, (ring F1)_1, (ring F1)_0, new OptionTable from {Multiplicity=>fs#0, PrintLevel=>2})
      )

  (toR1, fromR1) = switchCenter(R, (discs#1)#1);
  F1 = toR1 F;
  use ring F1
  time localBasis(F1, x,y);
  elapsedTime localBases F;
///

localBasisE = (F,x,y,opts) -> (
    -- F: RingElement, polynomial in kk[x,y], monic in y
    -- x,y are the variables
    -- This routine analyzes the singularities over x=0, and depending on opts.PrintLevel,
    -- displays some of this info.
    -- 
    -- this routine checks singularities, and bypasses the actual computation if possible
    (isDone, startB) := startSystem(F,x,y,opts);
    if isDone === DONE then 
        startB
    else
        -- for now, use localBasis1.
        B := localBasis1(F,x,y,startB,opts);
        B
    )

localBasis(RingElement, RingElement, RingElement) := opts -> (F,x,y) -> (
    assert(numgens ring F == 2);
    assert(index x === 0 or index x === 1);
    assert(index y === 0 or index y === 1);
    assert(index x =!= index y);
    origR := ring F;
    y2 := local y2;
    x2 := local x2;
    R := (coefficientRing origR)[y2,x2,MonomialOrder=>{1,1}];
    toR := map(R, origR, if index x === 0 then {x2,y2} else {y2,x2});
    fromR := map(origR, R, {y, x});
    B := localBasis1(toR F, 
        Start=> if opts.?Start then opts.Start else {},
        PrintLevel => opts.PrintLevel);
    B = apply(B, b -> {b#0, fromR b#1});
    apply(B, db -> new Divide from {db#1, new Power from {x, db#0}})
    )

-- First step: make a new ring, with the correct variables in place, in the order we need: [Y,X]
-- 
--localBasisA = (F,x,y,opts) -> (
--    -- assumptions: F = poly in x and y, monic in y, separable in y
    --              x and y are variables
    -- returns:
    -- list: {{n1, f1}, ..., {nr, fr}}
    --   where {ni, fi} represents the fraction fi/(x^ni).
    --   and fi is monic in y
--    )
-------------------------------------
-- Code being written: 28 Jan 2014 --
-------------------------------------
{*
localBasis(RingElement, RingElement, RingElement) := opts -> (F,gx,y) -> (
    assert(numgens ring F == 2);
    if numgens ring F =!= 2 then error "expected a polynomial ring in 2 variables";
    s := support gx;
    if #s =!= 1 then error "expected gx to be a univariate polynomial or 1/x";
    xindex := index if ring gx == ring F then s#0 else (
        if numerator gx != 1 or denominator gx != numerator s#0
        then error "expected gx to be a univariate polynomial or 1/x";
        numerator s#0
        );
    if xindex =!= 0 and xindex =!= 1 then error "expected gx to be a univariate polynomial or 1/x";
    if yindex =!= 0 and yindex =!= 1 then error "expected y to be a variable in the ring";
    if xindex == yindex then error "expected different variables";
    origR := ring F;
    y2 := local y2;
    x2 := local x2;
    R := (coefficientRing origR)[y2,x2,MonomialOrder=>{1,1}];
    toR := map(R, origR, if index x === 0 then {x2,y2} else {y2,x2});
    fromR := map(origR, R, {y, x});
    B := localBasis1(toR F, 
        Start=> if opts.?Start then opts.Start else {},
        PrintLevel => opts.PrintLevel);
    B = apply(B, b -> {b#0, fromR b#1});
    apply(B, db -> new Divide from {db#1, new Power from {x, db#0}})
    )
*}
transformToInfinity = (F) -> (
    -- R = ring of F, should be in 2 vars y > x.
    -- return a ring map f : Frac R --> frac R
    -- which is an involution, and under which
    -- numerator (f F) is monic in y.
    R := ring F;
    x := R_1;
    y := R_0;
    (monoms, cfs) := coefficients(F, Variables=>{y});
    monoms = flatten entries monoms;
    cfs = flatten entries cfs;
    n := degree_y(F);
    degs := for i from 1 to #monoms - 1 list (
        dy := degree_y(monoms#i);
        ceiling(degree_x(cfs#i)/(n-dy))
        );
    deg := max degs;
    map(frac R, frac R, {R_0/R_1^deg, 1/R_1})
    )
TEST ///
  -- test of transformToInfinity
  {*
  restart
  debug needsPackage "LocalBasis"
  *}
  kk = ZZ/2
  R = kk[y,x, MonomialOrder=>{1,1}]
  P = x^3+x^2+1
  F = y^3*(y-1) + P^2*y + P^3
  f = transformToInfinity F
  G = numerator(f F)

  B1 = localBasis1(F, FullBasis=>true)
  B2 = localBasisAtInfinity F
  value B1
  value B2

  B2 = B1/(e -> x^(e#0) * (f e#1))
  B3 = B2/(b -> (degree_x denominator b, numerator b))
  F' = numerator(f G)
  
  assert(F' == F)

  F = y^3*(y-1) + P^2*y + P^3 + x^10*y^2
  f = transformToInfinity F
  G = numerator(f F)
  F' = numerator(f G)  
  assert(F' == F)
///

localBasisAtInfinity = method(Options => options localBasis)
localBasisAtInfinity RingElement := opts -> (F) -> (
    -- MES todo: localBasis1 should start with a Start system
    --  like we do on the local basis function.
    R := ring F;
    f := transformToInfinity F;
    G := numerator (f F);
    B1 := localBasis1(G, FullBasis=>true);
    new PartialBasis from for e in B1 list (
        b := if #e#1 == 0 then f e#0 else R_1^(e#1#0#1) * (f e#0);
        d := degree(R_1, denominator b);
        {numerator b, if d == 0 then {} else {{R_1, d}}}
        --{degree(R_1, denominator b), numerator b}
        )
    )
getleadcoeff = (f) -> (
    a := numerator f;
    b := denominator f;
    y := (ring a)_0;
    d := degree(y, a);
    contract(y^d, a) / b
    )
reduceBy = (f, Binf) -> (
    -- f is a fraction of the form b(y,x)/P(x)
    R := ring f;
    y := (ring numerator f)_0;
    n := #Binf;
    reverse for i from 0 to n-1 list (
        d := n-i-1;
        lcf := contract(y^d, numerator f) / denominator f;
        if lcf == 0 then 0_R else (
            g := Binf#d;
            lcg := contract(y^d, numerator g) / denominator g;
            cf := lcf/lcg;
            f = f - cf * g;
            cf
            )
        )
    )
changeOfBasis = (B, Binf) -> for b in B list reduceBy(b, Binf)
-------------------------------------
TEST ///
  restart
  debug needsPackage "LocalBasis"
  kk = ZZ/2
  R = kk[y,x, MonomialOrder=>{1,1}]
  P = x^3+x^2+1
  F = y^3*(y-1) + P^2*y + P^3
  factorize discriminant(F,y) -- factor of x^4 in disc
  assert(
      localBasis(F, x, y, Multiplicity=>4)  -- Question: should Multiplicity=>2 or 4??
      == 
      {{2, y^3+y^2*x+y*x+x+1}}
      );
  localBasisAtInfinity F
///

TEST ///
  -- experimenting: taking local basis at infinity
  restart
  debug needsPackage "LocalBasis"
  kk = ZZ/2
  R = kk[y,x, MonomialOrder=>{1,1}]
  P = x^3+x^2+1
  F = y^3*(y-1) + P^2*y + P^3
  factorize discriminant(F, y)
  B = localBasis1(F, FullBasis=>true)
  B1 = localBasisAtInfinity F
  Ba = B/(b -> b#1/x^(b#0))
  Bi = B1/(b -> b#1/x^(b#0))
  M = matrix changeOfBasis(Ba,Bi)
  x*M
  assert (M * (transpose matrix {Bi}) - (transpose matrix {Ba}) == 0)

  kk = ZZ/3
  R = kk[y,x, MonomialOrder=>{1,1}]
  F = y^13+x^3*y^7+x^12
///

TEST ///
  restart
  debug needsPackage "LocalBasis"
  S = ZZ/3[x,y]
  F = y^13+x^3*y^7+x^12
  discriminant(F,y)
  localBasis(F,x,y)
  assert(
      localBasis(F,x,y)
      ==
      {{1, y^2}, {2, y^3+x*y}, {3, y^4+x*y^2}, {4, y^5+x*y^3}, 
       {5, y^7-x^2*y^3}, {7, y^8-x*y^6+x^2*y^4}, {8, y^9-x*y^7+x^2*y^5}, 
       {9, y^11+x^3*y^5}, {10, y^12+x^3*y^6}}
   )
///

TEST ///
  restart
  debug needsPackage "LocalBasis"
  S = ZZ/3[x,y]
  F = poly"(x-y)x(y+x2)3-y3(x3+xy-y2)"
  factorize discriminant(F,y)
  B = localBasis(F, x, y, PrintLevel=>3)
  B = B/value
  assert(
      localBasis(F,x,y)
      ==
      {{1, y}, {2, y^2}, {4, x^2*y+x*y^2+y^3}, 
      {7, x^6-x^5*y+x^4*y^2-x^4*y+x^3*y^2-x^2*y^3+x^2*y^2+x*y^3+y^4}}
   )

  R1 = ZZ/3[s,t, MonomialOrder=>{1,1}]
  G = numerator sub(F, {x=>1/t, y=>s/t^2})
  B1 = localBasis(G, t,s)
  KR1 = frac R1
  B1 = join({1_(frac R1), s, s^2, s^3}, B1)
  B1 = B1/(f -> sub(value f, {KR1_0=>y/x^2, KR1_1=>1/x}))
  B_0 - x * B1#1
  B_1 - x^2 * B1#2
  B_2 - x^2*B1#3 - x*B1#2 - B1#1
  B_3 - B1#4 - B1#3 + x*B1#3 - 1/x*B1#2 - B1#2 - x*B1#2 + 1/x * B1#1 + B1#1 - 1/x * B1#0
  B_3 - B1#4 + (-1 + x)*B1#3 + (-1/x - 1 - x)*B1#2 + (1/x + 1)*B1#1 - 1/x*B1#0
  M = -matrix{{-1, 0, 0, 0, 0},
         {0, -x, 0, 0, 0},
         {0, 0, -x^2, 0, 0},
         {0, -1, -x, -x^2, 0},
         {-1/x, 1/x+1, -1/x-1-x, -1+x, -1}}
 B' =  transpose matrix{B1}
 B = transpose matrix{prepend(1, B)}
 M * B' - B
 x*M
 B_(2,0) - B_(3,0) - x*B_(4,0)
///

TEST ///
  kk = ZZ/2
  S = kk[y,x,MonomialOrder=>{1,1}]
  F = (y^21
   +y^20*x
   +y^18*(x^3+x+1)
   +y^17*(x^3+1)
   +y^16*(x^4+x)
   +y^15*(x^7+x^6+x^3+x+1)
   +y^14*x^7
   +y^13*(x^8+x^7+x^6+x^4+x^3+1)
   +y^12*(x^9+x^8+x^4+1)
   +y^11*(x^11+x^9+x^8+x^5+x^4+x^3+x^2)
   +y^10*(x^12+x^9+x^8+x^7+x^5+x^3+x+1)
   +y^9*(x^14+x^13+x^10+x^9+x^8+x^7+x^6+x^3+x^2+1)
   +y^8*(x^13+x^9+x^8+x^6+x^4+x^3+x)
   +y^7*(x^16+x^15+x^13+x^12+x^11+x^7+x^3+x)
   +y^6*(x^17+x^16+x^13+x^9+x^8+x)
   +y^5*(x^17+x^16+x^12+x^7+x^5+x^2+x+1)
   +y^4*(x^19+x^16+x^15+x^12+x^6+x^5+x^3+1)
   +y^3*(x^18+x^15+x^12+x^10+x^9+x^7+x^4+x)
   +y^2*(x^22+x^21+x^20+x^18+x^13+x^12+x^9+x^8+x^7+x^5+x^4+x^3)
   +y*(x^23+x^22+x^20+x^17+x^15+x^14+x^12+x^9)
   +(x^25+x^23+x^19+x^17+x^15+x^13+x^11+x^5))
  factorize discriminant(F,y)
  assert(
      time localBasis(F,x,y)
      == 
      {{1, y^17+y^16+y^15+y^13+y^12+y^9+y^6+y}, 
          {2, y^19+y^16*x+y^16+y^15*x+y^15+y^13*x+y^13+y^12*x+y^11+
              y^10*x+y^10+y^9*x+y^8*x+y^8+y^7*x+y^7+y^5*x+y^4*x+
              y^3*x+y^3+y^2*x+y^2}, 
          {3, y^20+y^17*x+y^17+y^16*x^2+y^16*x+y^16+y^15*x^2+
              y^14*x+y^14+y^13*x^2+y^13*x+y^12*x^2+y^12+y^11*x+
              y^11+y^10*x+y^9*x^2+y^9*x+y^9+y^8*x+y^8+y^7*x^2+
              y^6*x+y^5*x^2+y^5*x+y^4*x+y^4+y^3*x^2+y^3*x+y^3+y^2*x^2}}
      )
///

TEST ///
  -- NEEDS IMPLEMENTATION OVER GF!!
  restart
  debug needsPackage "LocalBasis"
  kk = GF 4
  R1 = kk[y,x,MonomialOrder=>{1,1}]
  P = x^3+x^2+(kk_0)
  F = y^3*(y-1) + P^2*y + P^3
  factorize discriminant(F,y)
  localBasisCore(F, x, y, {}, new OptionTable) -- WRONG!!
  localBases(F, PrintLevel=>3)
///
---------------------

localBasis(RingElement, RingElement) := opts -> (F,gx) -> (
     checkInputPoly F;
     if first degree gx === 1 
     then localBasisDegreeOne(F,gx,opts)
     else localBasisDegreeN(F,gx,opts))

localBasis(Ring, RingElement) := opts -> (R,gx) -> (
     if ring gx =!= R then error "expected polynomial in given ring";
     F := (ideal R)_0;
     g := lift(gx, ring F);
     localBasis(F,g, opts)
     )

localBases = method(Options=>{PrintLevel=>0})
localBases RingElement := opts -> (F) -> (
     -- MAJOR ASSUMPTION: F is in a poly ring k[y,x]
     --  and F is monic in y, and separable over k[x].
     checkInputPoly F;
     R := ring F;
     time Delta := discriminant(F,R_0); -- w.r.t. y
     if Delta == 0 then error "Given extension is not separable";
     FACS := factorize Delta;
     FACS1 := select(FACS, g -> degree(R_1, g#1) > 0 and g#0 >= 2);
     apply(FACS1, f -> (f#0, f#1, time localBasis(F, f#1, opts, Multiplicity=>f#0))))

localBases Ring := opts -> (R) -> localBases((ideal R)_0, opts)

companionMatrix = method()
companionMatrix RingElement := (P) -> (
     -- P should be a MONIC polynomial in A[x].
     -- returns a matrix over A.
     R := ring P;
     kk := coefficientRing R;
     x := R_0;
     d := degree_x P;  
     cfs := for i from 0 to d-1 list coefficient(x^i, P);
     M := mutableMatrix(kk, d, d);
     for i from 0 to d-2 do M_(i+1,i) = 1_kk;
     for i from 0 to d-1 do M_(i,d-1) = -cfs#i;
     matrix M
     )

traceMap = method()
traceMap(Ring,Ring) := (R2, R1) -> (
     -- assumption: R2 = kk[a]/P(a)[x1,...,xr]
     --             R1 = kk[x1,...,xr]
     -- this returns a function:  F in R2 |--> tr(F) in kk[x1,...,xr]
     M := monoid R1;
     if monoid R2 =!= M then error "what the ^%&^%!";
     K := coefficientRing coefficientRing R2;
     kk := coefficientRing R1;
     P := (ideal K)_0;
     kka := ambient K;
     R3 := first flattenRing (kka M);
     a := sub(kka_0,R3);
     A := companionMatrix P; -- in kk
     ncols := numColumns A;
     monoms := for i from 0 to ncols-1 list a^i; -- in R3
     trs := for i from 0 to ncols-1 list trace A^i; -- in kk
     i := position(trs, a -> a != 0);
     if i === null then error "extension not separable";
     traceMatrix := matrix {trs}; -- in kk
     tr := (F) -> (
       (mns,cfs) := coefficients(sub(F,R3), Variables=>a, Monomials=>monoms);
       (traceMatrix * sub(cfs,R1))_(0,0)
       );
     P2 := sub(P, {(ring P)_0 => R2_1});
     Q := P2 // (R2_1 - (coefficientRing R2)_0);
     (tr, sub(monoms#i,K), Q)
     )

TEST ///
  -- testing traceMap
{*  
  restart
  needsPackage "LocalBasis"
*}
  kk = ZZ/3
  A = kk[a];
  ga = a^3+a^2-1;
  B = toField(A/ga);
  R1 = kk[Y,X];
  R2 = B (monoid R1);  -- it is currently required that the monoid be identical.
  (tr, c, Q) = traceMap(R2,R1)  
  assert((X-a) * Q == sub(ga, {A_0 => X}))
  use R2
  G1 = tr(c*(Y+a*X)*Q)
  C = kk[a1,a2,a3,X,Y]
  J = ideal(a1+a2+a3+1, a1*a2+a1*a3+a2*a3, a1*a2*a3-1)
  -- if a1,a2,a3 are a and its 2 conjugates, then the trace of (c*(Y+a*X)/gx) is
  -- G2/gx
  G2 = a1 * (Y+a1*X)*(X-a2)*(X-a3) + a2 * (Y+a2*X)*(X-a1)*(X-a3) + a3*(Y+a3*X)*(X-a1)*(X-a2)
  G2 = G2 % J;
  assert(sub(G2 % J, R1) == G1);
///

TEST ///
  -- testing traceMap
{*  
  restart
  needsPackage "LocalBasis"
*}
  kk = QQ
  A = kk[a];
  ga = a^3+a^2-1;
  B = toField(A/ga);
  R1 = kk[Y,X];
  R2 = B (monoid R1);  -- it is currently required that the monoid be identical.
  (tr, c, Q) = traceMap(R2,R1)  
  assert(c == 1);
  assert((X-a) * Q == sub(ga, {A_0 => X}));
  use R2;
  G1 = tr((Y+a*X)*Q)
  C = kk[a1,a2,a3,X,Y]
  J = ideal(a1+a2+a3+1, a1*a2+a1*a3+a2*a3, a1*a2*a3-1)
  -- if a1,a2,a3 are a and its 2 conjugates, then the trace of (c*(Y+a*X)/gx) is
  -- G2/gx
  G2 =  (Y+a1*X)*(X-a2)*(X-a3) +  (Y+a2*X)*(X-a1)*(X-a3) + (Y+a3*X)*(X-a1)*(X-a2)
  G2 = G2 % J;
  assert(sub(G2, R1) == G1);
///

integralBasis = method(Options => {PrintLevel=>0})
integralBasis Ring := opts -> (R) -> (
     B := integralBasis((ideal R)_0, opts);
     for B1 in B list (
	  -- B1 is of the form (multiplicity, denom, bas)
	  -- and bas is a list of fractions in Expression form
	  {B1#0, promote(B1#1, R),
	       for x in B1#2 list (
	  	    y := toList x;
	  	    z := toList y#1;
	  	    new Divide from {promote(y#0,R), new Power from {promote(z#0,R), z#1}}
		    )}
     ))
integralBasis RingElement := opts -> (F) -> (
     B := localBases(F, opts);
     -- now combineBases B
     )

fracs = (B,R) -> for x in B list (
	  y := toList x;
	  z := toList y#1;
	  {promote(y#0,R), promote(z#0,R), z#1}
	  )

ringFromFracs = method()
ringFromFracs(List,Symbol) := (B,s) -> (
     -- B is a list of (a,b,i), representing a/b^i.  a and b should be in the same ring.
     -- adjoin #B new fraction to B
     if #B == 0 then error "expected at least one fraction";
     R := ring B#0#0;
     for b in B do (if #b =!= 3 or not instance(b#0,R) or not instance(b#1,R) or not instance(b#2,ZZ)
       then error "expected list of triples (a,b,i) representing a/b^i");
     kk := coefficientRing R;
     S := R [s_0 .. s_(#B-1)];
     J := ideal for i from 0 to #B-1 list (B#i#1)^(B#i#2) * S_i - B#i#0;
     denoms := unique for b in B list promote(b#1,S);
     for d in denoms do J = trim saturate(J,d);
     S/J
     )

beginDocumentation()

doc ///
Key
  LocalBasis
Headline
  routines for integral bases and local integral bases in small characteristic
///

doc ///
   Key
     localBases
     (localBases,RingElement)
     (localBases,Ring)
   Headline
     local integral bases at each factor of the discriminant
   Usage
     L = localBases F
   Inputs
     F:RingElement
       in a polynomial ring {\tt k[y,x]} of {\bf finite characteristic}
   Outputs
     L:List
       of triples (m, P(x), B), where P(x) is a polynomial whose square divides the discriminant
       of F, m is the power P(x) occurs in the discriminant, and B is a local basis at P(x).
   Description
    Text
      F must be monic in y, and D = discriminant(F,y) must not be identically zero (otherwise, an error 
      is given).
 
      For each P(x), the corresponding list B is a list of pairs {d, b(y,x)}, such that b(y,x) is
      monic in y, and b(y,x)/P^d is integral over the localization $k[x]_{(P(x))}$.  
      The set of all of these fraction generates the
      local integral closure at P(x).
    Example
      kk = ZZ/2
      R1 = kk[y,x,MonomialOrder=>{1,1}]
      P = x^3+x^2+1
      F = y^3*(y-1) + P^2*y + P^3
      factorize discriminant(F,y)
      localBases F
   Caveat
     Currently, characteristic zero is not yet connected to this function.  Also, we still need to
     get this working for non-prime base fields of characteristic $p$.
   SeeAlso
     discriminant
     localBasis
     integralBasis
     integralClosure
     "IntegralClosure::icCharP"     
///

doc ///
   Key
     localBasis
     (localBasis,RingElement,RingElement)
     (localBasis,Ring,RingElement)
   Headline
     local integral basis
   Usage
     localBasis(F, g)
     localBasis(R, g)
   Inputs
     F:RingElement
       a polynomial in a ring {\tt kk[y,x]}, where kk is a finite field, F is monic of degree $n > 0$
       as a polynomial in y,
       and kk[y,x]/(F) is separable over kk[x] (i.e., discriminant(F,y) is not identically zero)
     g:RingElement
       an irreducible polynomial in kk[x].  All integral fractions with powers of g(x) 
       as their denominators will be found.
     R:Ring
       Instead of giving F as an argument, one can give the corresponding ring k[y,x]/(F).
   Outputs
     :List
       of fractions such that the local integral closure is generated over $k[x]_(g)$ by these fractions
   Description
    Text
    Example
      kk = ZZ/5
      R1 = kk[y,x,MonomialOrder=>{1,1}]
      P = x^3+x^2+1
      F = y^3*(y-1) + P^2*y + P^3
      factorize discriminant(F,y)
      localBasis(F, x^3+x^2+1)
   Caveat
     Not yet implemented in characteristic zero, or for non-prime finite fields
   SeeAlso
     localBases
     integralBasis
     integralClosure
     "IntegralClosure::icCharP"
///

doc ///
   Key
     (localBasis, RingElement, RingElement, RingElement)
   Headline
     local integral basis with specified denominator
   Usage
     B = localBasis(F,gx,y)
     B = localBasis(R,gx,y)
   Inputs
     F:RingElement
       a polynomial in a ring kk[x,y] with 2 variables: support gx, and y.
       Alternatively, one can input the ring kk[x,y]/F.  The
       variables x and y can be in any order, and there can be any monomial
       order on this ring.
     gx:RingElement
       a univariate polynomial in the same ring as F, or 1/x.
     y:RingElement
       a variable in the same ring as F
   Outputs
     B:List
       A basis over kk[x] for the local integral closure, the format is described below.
   Description
    Text
      The output B is a list of (unevaluated) fractions with denominator 
      powers of gx.  If gx=1/x, then what is returned is a local integral
      basis at infinity.
    Example
      kk = ZZ/2
      R = kk[x,y]
      P = x^3+x^2+1
      F = y^3*(y-1) + P^2*y + P^3
      factorize discriminant(F,y) -- factor of x^4 in disc
      B = localBasis(F, x, y, Multiplicity=>4)
      B = localBasis(F, x, y)
    Text
      Here is one way to obtain the numerators and powers in the denominators:
    Example
      B/numerator
      toList denominator B#0
      last toList denominator B#0
    Text
      The output consists of a list of fractions, which are monic in y.
   Caveat
     Not completely implemented yet!  This will replace the other uses of localBasis.
   SeeAlso
///

TEST ///
kk = ZZ/2
R1 = kk[y,x,MonomialOrder=>{1,1}]
P = x^3+x^2+1
F = y^3*(y-1) + P^2*y + P^3
factorize discriminant(F,y)
localBases(F, PrintLevel=>3)
///

TEST ///
S = ZZ/3[y,x, MonomialOrder=>{1,1}]
F = y^13+x^3*y^7+x^12
discriminant(F,y)
localBases F
///

TEST ///
S = ZZ/29[y,x, MonomialOrder=>{1,1}]
F = y^13+x^3*y^7+x^12
discriminant(F,y)
B = localBases F
R = S/F
localBases R
fr = fracs(B#0#2, R)
ringFromFracs(fr,symbol s)
///

TEST ///
kk = ZZ/2
S = kk[y,x, MonomialOrder=>Lex]
F = poly"(x-y)x(y+x2)3-y3(x3+xy-y2)"
localBasis(F,x)
localBases F
///

TEST ///
S = GF(4)[y,x, MonomialOrder=>Lex]
F = poly"(x-y)x(y+x2)3-y3(x3+xy-y2)"
discriminant(F,y)
localBasis(F,x)   -- FAILS RIGHT NOW
///

TEST ///
S = ZZ/3[y,x, MonomialOrder=>{1,1}]
F = poly"(x-y)x(y+x2)3-y3(x3+xy-y2)"
factorize discriminant(F,y)
localBases( F, PrintLevel=>3)
///

TEST ///
kk = ZZ/2
S = kk[y,x,MonomialOrder=>{1,1}]
F = (y^21
 +y^20*x
 +y^18*(x^3+x+1)
 +y^17*(x^3+1)
 +y^16*(x^4+x)
 +y^15*(x^7+x^6+x^3+x+1)
 +y^14*x^7
 +y^13*(x^8+x^7+x^6+x^4+x^3+1)
 +y^12*(x^9+x^8+x^4+1)
 +y^11*(x^11+x^9+x^8+x^5+x^4+x^3+x^2)
 +y^10*(x^12+x^9+x^8+x^7+x^5+x^3+x+1)
 +y^9*(x^14+x^13+x^10+x^9+x^8+x^7+x^6+x^3+x^2+1)
 +y^8*(x^13+x^9+x^8+x^6+x^4+x^3+x)
 +y^7*(x^16+x^15+x^13+x^12+x^11+x^7+x^3+x)
 +y^6*(x^17+x^16+x^13+x^9+x^8+x)
 +y^5*(x^17+x^16+x^12+x^7+x^5+x^2+x+1)
 +y^4*(x^19+x^16+x^15+x^12+x^6+x^5+x^3+1)
 +y^3*(x^18+x^15+x^12+x^10+x^9+x^7+x^4+x)
 +y^2*(x^22+x^21+x^20+x^18+x^13+x^12+x^9+x^8+x^7+x^5+x^4+x^3)
 +y*(x^23+x^22+x^20+x^17+x^15+x^14+x^12+x^9)
 +(x^25+x^23+x^19+x^17+x^15+x^13+x^11+x^5))
netList factorize discriminant(F,y)
eliminate(ideal F + ideal jacobian ideal F, y)

time localBasis(F,x)
time localBasis(F,x+1)
time localBasis(F,x^3+x+1)
time localBasis(F,x^3+x^2+1, PrintLevel=>3, Multiplicity => 4)

time localBasis(F,x^7+x^3+x^2+x+1, PrintLevel=>3, Multiplicity => 2)
time localBasis(F,x^17+x^16+x^15+x^14+x^13+x^11+x^8+x^6+x^5+x^2+1, PrintLevel => 3, Multiplicity => 2)
time localBases(F, PrintLevel => 3)
time localBases(F);
///


TEST ///
-- Should be the same example as the last one, except for the coeff ring is ZZ/3 not ZZ/2
kk = ZZ/3
S = kk[y,x,MonomialOrder=>{1,1}]
F = (y^21
 +y^20*x
 +y^18*(x^3+x+1)
 +y^17*(x^3+1)
 +y^16*(x^4+x)
 +y^15*(x^7+x^6+x^3+x+1)
 +y^14*x^7
 +y^13*(x^8+x^7+x^6+x^4+x^3+1)
 +y^12*(x^9+x^8+x^4+1)
 +y^11*(x^11+x^9+x^8+x^5+x^4+x^3+x^2)
 +y^10*(x^12+x^9+x^8+x^7+x^5+x^3+x+1)
 +y^9*(x^14+x^13+x^10+x^9+x^8+x^7+x^6+x^3+x^2+1)
 +y^8*(x^13+x^9+x^8+x^6+x^4+x^3+x)
 +y^7*(x^16+x^15+x^13+x^12+x^11+x^7+x^3+x)
 +y^6*(x^17+x^16+x^13+x^9+x^8+x)
 +y^5*(x^17+x^16+x^12+x^7+x^5+x^2+x+1)
 +y^4*(x^19+x^16+x^15+x^12+x^6+x^5+x^3+1)
 +y^3*(x^18+x^15+x^12+x^10+x^9+x^7+x^4+x)
 +y^2*(x^22+x^21+x^20+x^18+x^13+x^12+x^9+x^8+x^7+x^5+x^4+x^3)
 +y*(x^23+x^22+x^20+x^17+x^15+x^14+x^12+x^9)
 +(x^25+x^23+x^19+x^17+x^15+x^13+x^11+x^5))
netList factorize discriminant(F,y)
time localBases F
time localBasis(F,x)
///

TEST ///
-- Should be the same example as the last one, except for the coeff ring is ZZ/5 not ZZ/2 or ZZ/3
kk = ZZ/5
S = kk[y,x,MonomialOrder=>{1,1}]
F = (y^21
 +y^20*x
 +y^18*(x^3+x+1)
 +y^17*(x^3+1)
 +y^16*(x^4+x)
 +y^15*(x^7+x^6+x^3+x+1)
 +y^14*x^7
 +y^13*(x^8+x^7+x^6+x^4+x^3+1)
 +y^12*(x^9+x^8+x^4+1)
 +y^11*(x^11+x^9+x^8+x^5+x^4+x^3+x^2)
 +y^10*(x^12+x^9+x^8+x^7+x^5+x^3+x+1)
 +y^9*(x^14+x^13+x^10+x^9+x^8+x^7+x^6+x^3+x^2+1)
 +y^8*(x^13+x^9+x^8+x^6+x^4+x^3+x)
 +y^7*(x^16+x^15+x^13+x^12+x^11+x^7+x^3+x)
 +y^6*(x^17+x^16+x^13+x^9+x^8+x)
 +y^5*(x^17+x^16+x^12+x^7+x^5+x^2+x+1)
 +y^4*(x^19+x^16+x^15+x^12+x^6+x^5+x^3+1)
 +y^3*(x^18+x^15+x^12+x^10+x^9+x^7+x^4+x)
 +y^2*(x^22+x^21+x^20+x^18+x^13+x^12+x^9+x^8+x^7+x^5+x^4+x^3)
 +y*(x^23+x^22+x^20+x^17+x^15+x^14+x^12+x^9)
 +(x^25+x^23+x^19+x^17+x^15+x^13+x^11+x^5))
netList factorize discriminant(F,y)
time localBases F
time localBasis(F,x)
///

TEST ///
-- example: Leonard
  R = ZZ/19[y,x,MonomialOrder=>{1,1}]
  F = (y^2-y-x/3)^3-y*x^4*(y^2-y-x/3)-x^11

time localBasis(F,x)
netList factorize discriminant(F,y)
time localBases F
///

TEST ///
ZZZZZZZZZZZZZZZZZZZZZZ
S = ZZ/2[y,x, MonomialOrder=>{1,1}]
F = 27*x^11+27*x^4*y^3-9*x^5*y-27*x^4*y^2-27*y^6+27*x*y^4+81*y^5-9*x^2*y^2-54*x*y^3-81*y^4+x^3+9*x^2*y+27*x*y^2+27*y^3
factorize discriminant(F,y)
netList oo
localBases F
localBasis(F,x,y)
///

TEST ///
-- This one is REALLY slow for p=743, and not so great for p=101 either.
-- Of course, maybe we should not use this method for local bases in such characteristic.
--   or: maybe we can speed this code up.
p = 101
p = 743
S = ZZ/p[y,x, MonomialOrder=>{1,1}]
F = y^4+x^4*y^3+(x^7-x^4)*y^2+x^5
factor discriminant(F,y)
localBases F
///

TEST ///
R = ZZ/7[y,x]
ideal"(x2+y2-1)6 +27x2y2 + 3x8(x4+x3+3)3(x-1)3"
F = oo_0
factorize discriminant(F,y)
localBases F
///

randPoly = (deg, R) -> (
     b := basis(0,deg, R);
     (b * random(R^(numgens source b), R^1))_(0,0)
     )

genus0example = (kk) -> (
  t := local t;
  x := getSymbol "x";
  y := getSymbol "y";
  A := kk (monoid [t]);
  B := kk (monoid [t,x,y]);
  F := sub(randPoly(5, A) * A_0^5,B) - B_1 * sub(randPoly(7, A),B);
  G := sub(randPoly(5, A) * A_0^7,B) - B_2 * sub(randPoly(7, A),B);
  R := kk[y,x,MonomialOrder=>{1,1}];
  H := sub(resultant(F,G,B_0), {B_1 => R_0 + R_1, B_2 => R_0, B_0 => 0});
  (1/leadCoefficient H) * H)

TEST ///
  F = genus0example(ZZ/3);
  R = (ring F)/F;
  time localBases F
  netList oo
///  

TEST ///
-- Doug Leonard's generic curve example 1.
  leonard = (p) -> ZZ/p[y,x]/(y^5 + y^2*(x^4+x) + y*x^2 + x^12)
  R = leonard 101
    localBases R
  integralClosure R
///

TEST ///
-- Doug Leonard's generic curve example 2.
  leonard = (p) -> ZZ/p[z,y]/(z^12 + z^11 + z^10*y^2 + z^8 * y^9 + y^31);
  R = leonard 7
  time localBases R
  integralClosure R
///

TEST ///
{*
  restart
*}
  debug needsPackage "LocalBasis"
  --boehm1
  kk = ZZ/7 
  S = kk[u,v,z]
  I = ideal(v^4-2*u^3*z+3*u^2*z^2-2*v^2*z^2)
  R = kk[y,x,MonomialOrder=>{1,1}]
  F = sub(I_0, {u=>x, v=>y,z=>1})
  B = localBasis1(F, FullBasis=>true)
  B1 = localBasisAtInfinity F
  Ba = B/(b -> b#1/x^(b#0))
  Bi = B1/(b -> b#1/x^(b#0))
  M = matrix changeOfBasis(Ba,Bi)
  changeOfBasis(B,B1)
  XXXXXX
  
  -- todo: need a nice type for integral basis
  -- combine local bases into an integral basis
  -- change of basis: should take two "integral bases" and create matrix
  -- normal basis: modify an integral basis to be "normal at infinity"
  --
  -- F: if not monic in y, transformit so it is.
///
end

doc ///
Key
  LocalBasis
Headline
Description
  Text
  Example
Caveat
SeeAlso
///




doc ///
Key
Headline
Usage
Inputs
Outputs
Consequences
Description
  Text
  Example
  Code
  Pre
Caveat
SeeAlso
///

TEST ///
-- test code and assertions here
-- may have as many TEST sections as needed
///



-- example 2 -- from Greuel-Laplagne-Seelisch arXiv:0904.3561v1
restart

loadPackage "LocalBasis"
kk = ZZ/2
S = kk[y,x, MonomialOrder=>Lex]
F = poly"(x-y)x(y+x2)3-y3(x3+xy-y2)"
localBasis(F,x)
netList oo

S = kk[x,y]
F = sub(F,S)
netList puiseux(F,20)
R = S/F
integralClosure R
J = ideal oo
J = trim J
use ring J
trim sub(J, {x=>0})
decompose oo
primaryDecomposition o110
oo/degree
loadPackage "TraceForm"
traceForm 

A = kk[x]
K = frac A
R = A[y]
S = K[y]
F = poly"(x-y)x(y+x2)3-y3(x3+xy-y2)"
B = S/F
traceForm B



debug loadPackage "LocalBasis"
S = ZZ/2[y,x, MonomialOrder=>{1,1}]
S = ZZ/3[y,x, MonomialOrder=>{1,1}]
F = poly"(x-y)x(y+x2)3-y3(x3+xy-y2)"
discriminant(F,y)
eliminate(ideal F + ideal jacobian ideal F, y)

R = S/F
B = time localBasis1 R

apply(x^7 * icFracP R, numerator)

A = ZZ/2[x,y,t]
I = ideal(x*t-y, poly"(x-y)x(y+x2)3-y3(x3+xy-y2)")
I1 = saturate(I,x)
eliminate(I1, y)
S = QQ[x,y]
F = poly"(x-y)x(y+x2)3-y3(x3+xy-y2)"
R = S/F
integralClosure R
for f in icFractions R list x^7*f

-- example 3
q = 2 -- or q = 3
kk = ZZ/2
kk = GF(4)
S = kk[y,x,MonomialOrder=>{1,1}]
F = (y^21
 +y^20*x
 +y^18*(x^3+x+1)
 +y^17*(x^3+1)
 +y^16*(x^4+x)
 +y^15*(x^7+x^6+x^3+x+1)
 +y^14*x^7
 +y^13*(x^8+x^7+x^6+x^4+x^3+1)
 +y^12*(x^9+x^8+x^4+1)
 +y^11*(x^11+x^9+x^8+x^5+x^4+x^3+x^2)
 +y^10*(x^12+x^9+x^8+x^7+x^5+x^3+x+1)
 +y^9*(x^14+x^13+x^10+x^9+x^8+x^7+x^6+x^3+x^2+1)
 +y^8*(x^13+x^9+x^8+x^6+x^4+x^3+x)
 +y^7*(x^16+x^15+x^13+x^12+x^11+x^7+x^3+x)
 +y^6*(x^17+x^16+x^13+x^9+x^8+x)
 +y^5*(x^17+x^16+x^12+x^7+x^5+x^2+x+1)
 +y^4*(x^19+x^16+x^15+x^12+x^6+x^5+x^3+1)
 +y^3*(x^18+x^15+x^12+x^10+x^9+x^7+x^4+x)
 +y^2*(x^22+x^21+x^20+x^18+x^13+x^12+x^9+x^8+x^7+x^5+x^4+x^3)
 +y*(x^23+x^22+x^20+x^17+x^15+x^14+x^12+x^9)
 +(x^25+x^23+x^19+x^17+x^15+x^13+x^11+x^5))
factor discriminant(F,y)
eliminate(ideal F + ideal jacobian ideal F, y)

localBasis(F,x)
-- at x=0
R = S/F
time localBasis1 R

-- at x=1
use ring F
F = sub(F, {x=>x+1})
R = S/F
time localBasis1 R
-------------------------------------------------
-- example 1
-- 2/5/10: getting back into it
-- let's see if the code is correct on this example
restart
debug loadPackage "LocalBasis"
S = ZZ/3[y,x, MonomialOrder=>{1,1}]
F = y^13+x^3*y^7+x^12
discriminant(F,y)
eliminate(ideal F + ideal jacobian ideal F, y)


localBasis(F,x)
netList oo
R = S/F
time C = localBasis1 R

-- scratch work looking at algorithm
B = for i to 12 list y^i
Bp = for b in B list (b^3 % x^3)
B = {x, x*y, x*y^2, x*y^3, x*y^4, y^5, y^6, y^7, y^8, y^9, y^10, y^11, y^12} -- 1/x * B is 
Bp = for b in B list (b^3 % x^6)
----------------------------
restart
debug loadPackage "TowerRings"
debug loadPackage "LocalBasis"

p = 101
p = 743
S = ZZ/p[y,x, MonomialOrder=>{1,1}]
F = y^4+x^4*y^3+(x^7-x^4)*y^2+x^5
factor discriminant(F,y)
eliminate(ideal F + ideal jacobian ideal F, y)

R = S/F
time C = localBasis1 R
time integralClosure R
icFractions R

S = ZZ/2[y,x, MonomialOrder=>{1,1}]
F = 27*x^11+27*x^4*y^3-9*x^5*y-27*x^4*y^2-27*y^6+27*x*y^4+81*y^5-9*x^2*y^2-54*x*y^3-81*y^4+x^3+9*x^2*y+27*x*y^2+27*y^3
FACS = factorize discriminant(F,y)
time localBases F
use ring F
localCheck1(F, FACS#0#0)

findH o20_1
findH o20_2
findH o20_3
findH o20_4
findH o20_5
findH o20_6
findH o20_7

-- example: Leonard
loadPackage "LocalBasis"
  R = ZZ/19[y,x,MonomialOrder=>{1,1}]
  F = (y^2-y-x/3)^3-y*x^4*(y^2-y-x/3)-x^11

netList time localBasis(F,x)
discriminant(F,y)
netList factorize oo

--- localCheck1 examples
restart
loadPackage "LocalBasis"
S = ZZ/2[y,x, MonomialOrder=>{1,1}]
S = ZZ/2[x,y, MonomialOrder=>{1,1}]
S = ZZ/7[x,y]
F = 27*x^11+27*x^4*y^3-9*x^5*y-27*x^4*y^2-27*y^6+27*x*y^4+81*y^5-9*x^2*y^2-54*x*y^3-81*y^4+x^3+9*x^2*y+27*x*y^2+27*y^3
FACS = select(factorize discriminant(F,y), g -> degree_x(g#1) > 0 and g#0 >= 2)
time apply(FACS, f -> if f#0 > 1 then time localCheck1(F, f#1))
time localBasis(F,x)

S = ZZ/2[y,x,MonomialOrder=>{1,1}]
F = y^12+y^11+y^10*x^2+y^8*x^9+x^31
factorize discriminant(F,y)
time L = localBasis(F,x)
netList L
A = ZZ/2[w_0..w_9,y,x, MonomialOrder=>{10,1,1}]
J = ideal (for i from 0 to #L-1 list sub(L#i#0,A) - A_i  * sub(L#i#1, A))
saturate(J,x)

-- small example with wild ramification
R = ZZ/3[y,x,MonomialOrder=>{1,1}]
F = poly"y3(y2+2y+2)+x(y2+2)+x3"
decompose(ideal F + ideal jacobian ideal F) -- 1 singular point
factorize discriminant(F,y)
time localBases(F)

FACS = select(factorize discriminant(F,y), g -> degree_x(g#1) > 0 and g#0 >= 2)
time apply(FACS, f -> if f#0 > 1 then time localCheck1(F, f#1, f#0))
localBases F

time localBasis(F,x-1) -- this one appears to be incorrect...!  IT IS WRONG: localBasis does NOT handle change of coord!
time localBasis(F,x) 
localCheck1(F,x-1)
h = y^2+2*y+2
g = y^2+2
g*diff(y,h) - h*diff(y,g)
g
diff(y,h)

restart
debug loadPackage "LocalBasis"
S = ZZ/2[y,x, MonomialOrder=>{1,1}]
F = 27*x^11+27*x^4*y^3-9*x^5*y-27*x^4*y^2-27*y^6+27*x*y^4+81*y^5-9*x^2*y^2-54*x*y^3-81*y^4+x^3+9*x^2*y+27*x*y^2+27*y^3
factorize discriminant(F,y)
netList oo
localCheck1(F,x,34)
R = S/F
localBasis1 R
localBasis1(R, Start=>{{1,y^4+y^2}})
use ring F
netList localBasis1(F, Start=>{{1,y^4+y^2}})

BtoC({},R)
BtoC({{3,y^4-y}},R)

(f1,g,h) = localSetup(F,x)
h g sub(f1, (ring f1)_1 => 0)

(F',g,h) = localSetup(F,x+1)
(F',g,h) = localSetup(F,x^2+x+1)
(F',g,h) = localSetup(F,x^3+x^2+1)

F0 = sub(F', (ring F')_1 => 0)
F1 = sub(diff((ring F')_1, F'), (ring F')_1 => 0)
assert(F0 == h g F0)
assert(F1 == h g F1)
g F0
squareFreeDecomposition oo
apply(oo, z -> {z#0, h z#1})

localBasis(F,x, PrintLevel=>1)
localBasis(F,x+1)
localBasis(F,x^2+x+1)
localBasis(F,x^3+x^2+1)

time localBases(F, PrintLevel => 1)
netList oo

restart
debug loadPackage "LocalBasis"
S = ZZ/2[y,x]
F = 27*x^11+27*x^4*y^3-9*x^5*y-27*x^4*y^2-27*y^6+27*x*y^4+81*y^5-9*x^2*y^2-54*x*y^3-81*y^4+x^3+9*x^2*y+27*x*y^2+27*y^3
time localBases(F, PrintLevel => 1)

----------------------
-- test of traces
restart
loadPackage "LocalBasis"
kk = ZZ/2
R1 = kk[Y,X,MonomialOrder=>{1,1}]
P = X^3+X^2+1
K = toField(kk[a]/(a^3+a^2+1))
R = K (monoid R1)
F = Y^20+a^2*Y^19*X+Y^19+a^2*Y^18*X+(a+1)*Y^18+(a^2+a)*Y^17*X+(a+1)*Y^17+Y^16*X+Y^16+(a^2+a+1)*Y^15*X+(a^2+a)*Y^15+(a+1)*Y^14*X+(a^2+a)*Y^14+(a^2+a+1)*Y^13*X+(a^2+a)*Y^13+a*Y^12*X+Y^12+Y^11*X+(a+1)*Y^11+(a^2+1)*Y^10*X+Y^10+Y^9*X+a*Y^9+(a^2+a+1)*Y^8*X+(a^2+1)*Y^8+(a^2+a)*Y^7*X+a^2*Y^7+(a+1)*Y^6+(a^2+a)*Y^5*X+(a^2+a)*Y^5+(a^2+a+1)*Y^4*X+Y^3*X+(a^2+a+1)*Y^3+(a^2+a)*Y^2*X+(a^2+a+1)*Y^2+a^2*Y*X+(a^2+1)*Y+a*X+a+1
-- want to find tr(F) in kk[Y,X].
-- want to find tr(F/(X-a)^2) in 1/P(X)^2 kk[Y,X], where P(x) = x^3 + x^2 + 1.


P1 = sub(P,R)
Q1 = P1 // (X-a)
(tr,c,Q1) = traceMap(R,R1)
tr(F * Q1^2)
tr(F * Q1)
tr(F)


kk = ZZ/2
R1 = kk[Y,X,MonomialOrder=>{1,1}]
P = X^2+X+1
K = toField(kk[a]/(a^2+a+1))
R = K (monoid R1)
F = Y^20+a^2*Y^19*X+Y^19+a^2*Y^18*X+(a+1)*Y^18+(a^2+a)*Y^17*X+(a+1)*Y^17+Y^16*X+Y^16+(a^2+a+1)*Y^15*X+(a^2+a)*Y^15+(a+1)*Y^14*X+(a^2+a)*Y^14+(a^2+a+1)*Y^13*X+(a^2+a)*Y^13+a*Y^12*X+Y^12+Y^11*X+(a+1)*Y^11+(a^2+1)*Y^10*X+Y^10+Y^9*X+a*Y^9+(a^2+a+1)*Y^8*X+(a^2+1)*Y^8+(a^2+a)*Y^7*X+a^2*Y^7+(a+1)*Y^6+(a^2+a)*Y^5*X+(a^2+a)*Y^5+(a^2+a+1)*Y^4*X+Y^3*X+(a^2+a+1)*Y^3+(a^2+a)*Y^2*X+(a^2+a+1)*Y^2+a^2*Y*X+(a^2+1)*Y+a*X+a+1
tr = traceMap(R,R1)
tr (1_R)
tr (a_R)
tr (a*F)
tr (a_R)^2
Q = sub(P,R)//(X-a)
tr(Q^2*F)

-- example:
kk = ZZ/2
R1 = kk[y,x,MonomialOrder=>{1,1}]
P = x^2+x+1
F = y^3*(y-1) + P^2*y + P^3
F = y^3+ P^2*y + P^3
discriminant(F,y)
factor oo
localBases F
L = toField(kk[a]/(a^2+a+1))
R = L (monoid R1)
Q = sub(P,R)//(x-a)
tr = traceMap(R,R1)
tr 1_R          
tr a_R
tr (a*Q)
tr (a*Q^2)
tr (Q)
tr (Q^2)

-- traces
restart
loadPackage "LocalBasis"
kk = ZZ/2
R1 = kk[y,x,MonomialOrder=>{1,1}]
P = x^3+x^2+1
F = y^3*(y-1) + P^2*y + P^3
time localBases F
netList oo
F = y^3+ P^2*y + P^3
discriminant(F,y)
factor oo

---------------------------------
-- Example polynomials for ramification info
---------------------------------
R = ZZ/101[x,y]
f0 = y-1
f1 = y
f2 = y^2-y+1
f3 = y-2
g = y^5-y-1
F = f0*f1^2*f2^3 + x * g * f0 + x^2 * y^5
factorize discriminant(F,y)
netList oo

F = f0*f1^2*f2^4 + x * g * f0 * f1^3 + x^2 * y^5 + x^8
factorize discriminant(F,y)
netList oo

---------------------------------
-- Test of localSetup -----------
---------------------------------
restart
installPackage "TowerRings"
installPackage "LocalBasis"
viewHelp LocalBasis
debug loadPackage "LocalBasis"
kk = ZZ/2
R1 = kk[y,x,MonomialOrder=>{1,1}]
P = x^3+x^2+1
F = y^3*(y-1) + P^2*y + P^3
factorize discriminant(F,y)
localBases F


g0 = sub(G, (ring G)_1 => 0)
g1 = sub(diff((ring G)_1, G), (ring G)_1 => 0)

localBasisDegreeOne(F, x)


--localSetup(F,x)
(A,AF) = localSetup(F,x^3+x^2+1)
AF
Ay0 = towerRing(ZZ/2, (symbol a,symbol y))
Ay = Ay0/(a^3+a^2+1)
toAy = map(Ay,A,{Ay_0, 0_Ay, Ay_1})
toAy AF  -- CRASH

---------------------------------
-- Getting the coeff of y^0, y^1 in F (in tower ring)
