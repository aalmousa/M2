newPackage(
        "AdjoinRoots",
        Version => "0.2", 
        Date => "30 Mar 2015",
        Authors => {{Name => "Mike Stillman", 
                  Email => "", 
                  HomePage => ""}},
        Headline => "Adjoining roots to fields",
        DebuggingMode => true
        )

export {
    "adjoinRoot",
    "switchCenter" -- this is an easier "helper" function
    }
protect PrimitiveInfo
protect TowerData
protect toNew
protect fromNew
protect toPrimitive
protect fromPrimitive
protect inclusion

setPrimitiveInfo = method()
setPrimitiveInfo Ring := (R) -> (
    if R === QQ or isFinitePrimeField R then 
      R.PrimitiveInfo = {map(R,R), map(R,R)}
    else
      error "cannot set primitive info with such limited information";
    )
setPrimitiveInfo(Ring,RingElement) := (A,a) -> (
    -- sets the primitive info for B = ring a;
    B := ring a;
    C := ambient B; -- or ambient coefficientRing B? Should be of the form QQ[ar, ... a0]
    (toA1, fromA1) := A.PrimitiveInfo; -- maps A --> A1, A1 --> A, where A1 = QQ[z]/F(z).
    )

makePrimitive = method()
makePrimitive(Ring,RingElement) := (A,a) -> (
    -- f is in a ring A[x]
    -- B = A[x]/f.
    -- we want an isomorphism toPrimitive: B --> S = QQ[z]/G(z).
    -- A is a tower ring
    -- B = amb/G is the flattened primitive ring element corresponding to A: 
    -- create a new polynomial ring S = QQ[var]/G'
    -- and ring maps toPrimitive: A --> S, and fromPrimitive: S --> A (inverse map);.
    -- and a list, s.t. for each generator of A, has image of that element in S. (don't really need this?)
    -- given such a tower ring A, once this function has run, we get this data from: 
    --  getPrimitiveInfo A, which returns (toPrimitive, fromPrimitive)
    -- 
    -- a = adjoinRoot g, where g is in A[x].
    -- first case: 
    --   A = QQ[a]/f(a).
    --   B = ring a = QQ[b,a]/(fa, gab)
    -- we look to see if b generates this ring. If so, we use that.
    --   if not, we need to take something like b+a (or some other sum).
    )

-- above this is my new code (21 April 2018) trying to allow factorizations over tower rings.
-- What do we need to determine the primitive extension of A = A0[b]/g(b)?
--   1. toPrimitive, fromPrimitive for A0
--   2. if A == A0 (i.e. if g(b) is linear in b), then we are done.
--   3. otherwise:
--     translate g(b;as), and the polynomials f(z) into a new ring.
--     the ring should be QQ[x,z], and we should have polynomials f(z), g(x,z).
--       Find h(x) = res(f(z), g(x,z), z):
--        if irreducible, then the extension is generated by x.
--        if not, try x+z:
--          h(x) = res(f(z), g(x-z,z), z)
--          (keep trying x-iz until we find one?
--       Answer will be h(x).
--     Now we need the maps: QQ[ar, a_(r-1), ..., a_0] --> QQ[x]
--        and the other way around
--       OR: A --> QQ[x]/(h(x)).
--     How to get the images of the elements a_i in here?
--      First, take their image in QQ[x,z], using the same info for A0
--      Second, we need to know where z goes in this ring.
--     QQ[x,z]/(f(z), g(x,z)) --> QQ[x]/(h(x))
--      x --> x (or x + z, etc)
--      what about z --> ?
--       Good question?
--       One way: compute a GB.  Is rthere a direct way?
--     also, we will need the images in QQ[x,z]
--     Find the minimal polynomial of b (resultant(g(b),
----------------------------------------------------------------------


-- this seems to be already defined now
--isFinitePrimeField = method()
--isFinitePrimeField Ring := (R) -> R.?order and R.order == char R

-- TODO: (14 March 2015 MES)
--   add tests:
--     base = ZZ/p
--     base = GF (might not work)
--     base = QQ
--     base = toField'd extension of QQ
--   get to work with tower rings too?

--current verion
adjoinRoot = method(Options => {Variable=>null})
adjoinRoot RingElement := opts -> (f) -> (
    -- returns a root of the irreducible univariate polynomial f, 
    -- possibly after an extension of fields
    R := ring f;
    supp := support f;
    if #supp != 1 or numgens R =!= 1 then error "expected a univariate polynomial";
    x := supp#0;
    if degree(x,f) == 1 then (
        a := coefficient(x, f);
        b := coefficient(1_R, f);
        if a == 1 then -b else -b/a
        )
    else (
        -- Here we need to add a root to kk.
        kk := coefficientRing R;
        if opts.Variable =!= null and not instance(opts.Variable, Symbol) then
            error "Variable given is not a symbol";
        if not isPolynomialRing kk then (
            -- In this case, kk is QQ, or a finite prime field.
            -- (what about GF?)
            v := if opts.Variable === null then getSymbol "a"
            else opts.Variable;
            A1 := kk (monoid[v]);
            A2 := A1/(sub(f, x=> A1_0));
            A3 := if isFinitePrimeField kk then
                    GF(A2)
                  else
                    toField A2;
            A3_0
            )
        else (
            kk = coefficientRing kk;  -- we expect that kk is a 'toField'ed field
            I := ideal kk; -- this should be in a "triangular form"
            kk1 := coefficientRing kk;
            if instance(kk1, PolynomialRing) then error "expected the original ring in the form toField(kk[vars]/I), where kk is a prime field";
            n := numgens kk;
            v = if opts.Variable === null then vars n else opts.Variable;
            A1 = kk1 (monoid[v, generators kk, MonomialOrder=>Lex]);
            to1 := map(A1, ring I, drop(gens A1, 1)); -- map on inner variables
            to2 := map(A1, R, gens A1);
            J := ideal to2 f + to1 I;
            A2 = A1/J;
            A3 = toField(A2);
            A3_0
            )
        )
    )


-- new version
adjoinRootToTower = method(Options => {Variable=>null})
adjoinRootToTower RingElement := opts -> (f) -> (
    -- f is a polynomial in a ring A[x].
    --   where A is a prime field kk, or of the form B/triangularIdeal
    --   where B = kk[a_(r-1), a_(r-2), ..., a_0, MonomialOrder=>Lex].
    -- result:
    --   The element a_r in a ring of the form A' = B'/triangularIdeal'
    --   where kk[a_r, ..., a_0, MonomialOrdder=>Lex]
    --   such that A[x]/f is isomorphic to B'/triangularIdeal'.
    -- Also resulting, and stashed in A.TowerData#f is: (inc,toNew,fromNew,toPrimitive,fromPrimitive)
    --   where inc: A --> A' is the inclusion map, or should it be B --> B'?
    --   and also the isomorphism toNew: A[x]/f --> A'
    --                          fromNew: A' --> A[x]/f
    -- It is possible, if f is linear in x, that a field extension will not be constructed.
    -- In this case inc, toNew, fromNew will be the identity ring maps.
    -- returns a root of the irreducible univariate polynomial f, 
    -- possibly after an extension of fields
    -- NOTES:
    --   a. don't use toField here.
    --   b. for GF, we need to make these maps.  How to do that?
    --   c. also keep the corresponding primitive extension, and maps to/from that.
    R := ring f;
    supp := support f;
    if numgens R =!= 1 then error "expected a univariate polynomial";
    x := supp#0;
    if degree(x,f) == 1 then (
        << "adjoinRootToTower: case 1" << endl;
        a := coefficient(x, f);
        b := coefficient(1_R, f);
        if a == 1 then -b else -b//a
        )
    else (
        -- Here we need to add a root to kk.
        kk := coefficientRing R;
        if opts.Variable =!= null and not instance(opts.Variable, Symbol) then
            error "Variable given is not a symbol";
        if not isPolynomialRing kk then (
            -- In this case, kk is QQ, or a finite prime field.
            -- (what about GF?)
            << "adjoinRootToTower: case 2" << endl;
            v := if opts.Variable === null then getSymbol "a"
            else opts.Variable;
            A1 := kk (monoid[v]);
            A2 := A1/(sub(f, x=> A1_0));
            A3 := if isFinitePrimeField kk then
                    GF(A2)
                  else
                    toField A2;
            Old := (ring f)/f;
            New := A3;
            Prim := A3;
            tonew := map(New, Old, {New_0});
            fromnew := map(Old, New, {Old_0});
            New#TowerData = new HashTable from {
                inclusion => map(New, kk),
                toNew => tonew,
                fromNew => fromnew,
                toPrimitive => tonew,
                fromPrimitive => fromnew
                };
            A3_0
            )
        else (
            << "adjoinRootToTower: case 3" << endl;
            kk = coefficientRing kk;  -- we expect that kk is a 'toField'ed field
            I := ideal kk; -- this should be in a "triangular form"
            kk1 := coefficientRing kk;
            if instance(kk1, PolynomialRing) then error "expected the original ring in the form toField(kk[vars]/I), where kk is a prime field";
            n := numgens kk;
            v = if opts.Variable === null then vars n else opts.Variable;
            A1 = kk1 (monoid[v, generators kk, MonomialOrder=>Lex]);
            to1 := map(A1, ring I, drop(gens A1, 1)); -- map on inner variables
            to2 := map(A1, R, gens A1);
            J := ideal to2 f + to1 I;
            A2 = A1/J;
            A3 = toField(A2);
            Old = (ring f)/f;
            New = A3;
            Prim = null;
            oldvars := promote(vars kk, Old);
            newvars := promote(vars coefficientRing New, New);
            tonew = map(New, Old, newvars);
            fromnew = map(Old, New, matrix{{Old_0}}|oldvars);
            New#TowerData = new HashTable from {
                inclusion => map(New, coefficientRing R, drop(flatten entries newvars, 1)),
                toNew => tonew,
                fromNew => fromnew,
                toPrimitive => null, -- need to fill this in
                fromPrimitive => null
                };
            A3_0
            )
        )
    )

TEST ///
  restart
  debug needsPackage "AdjoinRoots"
  T0 = QQ
  R1 = T0[x]
  a1 = adjoinRootToTower(x^2-2)
  T1 = ring a1

  TD = T1#TowerData
  coefficientRing T1 -- fails in char p
  ambient coefficientRing T1 
  
  R2 = T1[x]
  F = x^3-T1_0*x-1
  a2 = adjoinRootToTower F  
  T2 = ring a2

  use R2
  F = x^3-T1_0*x-1
  a2 = adjoinRootToTower F  
  T2 = ring a2

  R3 = T2[x]
  F = x^2-T2_0-T2_1
  a3 = adjoinRootToTower F  
  T3 = ring a3

  ambient RingMap := (F) -> (
      S := source F;
      T := target F;
      map(ambient coefficientRing T, ambient coefficientRing T, lift(F.matrix, ambient coefficientRing T))
      )
  ambient TD#toNew
  ambient coefficientRing ring a1   -- WARNING: this is a difference currently between char 0 and p ??
  
  A1 = ambient coefficientRing B1
  
  R2 = B1[x]
  F = x^3-B1_0*x-1
  
  a2 = adjoinRootToTower F
  B2 = ring a2
  TD = B2#TowerData
  assert (TD#toNew TD#fromNew B2_0 == B2_0)

  use R2
  a2' = adjoinRootToTower (a*x-(a+1))

  
///

TEST ///
  restart
  debug needsPackage "AdjoinRoots"
  A0 = ZZ/101  
  A1 = A0[x]
  factor(x^3-x-4)
  a1 = adjoinRootToTower(x^3-x-4)
  TD = A0#(TowerData,x^3-x-4)
  ambient ambient ring a1  -- WARNING: this is a difference currently between char 0 and p!
///

switchCenter = method()
switchCenter(Ring, RingElement) := (origR,gx) -> (
    -- origR should be a polynomial ring, over a field kk
    -- gx should be a polynomial, involving exactly one variable in x, possibly over the same ring.
    -- adjoin a root 'a' to kk if needed to get a new ring R1 = B (monoid origR), and
    -- then return inc : origR --> R, identity on the variables
    --        and  toNewRing : R --> R, x -> x+a, y -> y 
    --        and  toOld : R --> R  which sends x -> x-a, y -> y.
    kk := coefficientRing origR;
    supp := support gx;
    if #supp != 1 then error "expected center to be a polynomial involving one variable";
    x := supp#0;
    ix := index x;
    x1 := local x1;
    A := kk[x1];
    toA := map(A,origR, for v in gens origR list if v == x then A_0 else 0_A);
    gx1 := toA gx;
    a := adjoinRoot gx1;
    local R;
    if ring a === kk then (
        R = origR;
        )
    else (
        if not (ring a).?order then
            (ring a).order = (char kk)^(degree(x,gx));
        R = (ring a)(monoid origR)
        );
    vars := for i from 0 to numgens R - 1 list (
        if i == ix then R_i + a else R_i
        );
    vars2 := for i from 0 to numgens R - 1 list (
        if i == ix then R_i - a else R_i
        );
    inc := map(R,origR);
    toCenter := map(R,R,vars);
    fromCenter := map(R,R,vars2); 
    (inc,toCenter,fromCenter)
    )

TEST ///
{*
  restart
  loadPackage "AdjoinRoots"
*}
  A1 = ZZ/101
  B = A1[x]
  gx = x^2-2*x-14

  b = adjoinRoot(gx, Variable=>b)
  A2 = ring b
  B1 = A1[x,y]
  B2 = A2[x,y]
  inc = map(B2,B1)
  change = map(B2,B2,{x+b,y})
  change^-1
  use B1
  F = (y^6-x*y^4-x^3*y^2-1);
  G = sub(change^-1 change inc F, B1) -- what is a better way to lift to B1?
  assert(F == G)
  
  (inc,toA,fromA) = switchCenter(ring F, x+7)
  G = toA F
  factor discriminant(G,y)
  G = inc F
  assert(fromA toA G == G)
///

TEST ///
  S = ZZ/2[y,x, MonomialOrder=>{1,1}]
  F = 27*x^11+27*x^4*y^3-9*x^5*y-27*x^4*y^2-
       27*y^6+27*x*y^4+81*y^5-9*x^2*y^2-54*x*y^3-
       81*y^4+x^3+9*x^2*y+27*x*y^2+27*y^3;
  factor discriminant(F,y)
  (inc, toA, fromA) = switchCenter(S,x^3+x^2+1)
  F1 = toA inc F
  factor discriminant(F1,(ring F1)_0)
///

isTriangular = method()
isTriangular List := (L) -> true

debug Core
-*
makeTower = method()
makeTower List := (L) -> (
    -- L should be triangular, starting with the lowest variable
    -- every element of L should be in the same ring
    R := ring L#0;
    if not all(L, f -> ring f === R) then error "expected all elements to be in the same ring";
    K := coefficientRing R;
    --if K =!= QQ and not isPrimeField K then error "expected a polynomial ring over a prime field";
    if not instance(R,PolynomialRing) then error "expected a polynomial ring";
    if numgens R != #L then error ("expected exactly "|#L|" generators in the ring");
    if not isTriangular L then error "expected a triangular set";
    L0 := K;
    x := local x;
    for i from 0 to #L-1 do (
        A := L0[x];
        phi := map(A, R, join(toList((numgens R-i-1):0), {x}, for i from 0 to i-1 list L0_(numgens R-i-1)));
        G := phi L#i;
        L1 := adjoinRoot(G, Variable=>R#generatorSymbols#(numgens R-i-1));
        L0 = L1;
        );
    L0
    )
*-

beginDocumentation()

doc ///
Key
  AdjoinRoots
Headline
  simplify adjoining roots of polynomials to fields
Description
  Text
Caveat
  Needs testing.
///

doc ///
   Key
       adjoinRoot
       (adjoinRoot,RingElement)
   Headline
       create a finite extension field
   Usage
       alpha = adjoinRoot(f, Variable=>a)
   Inputs
       f:RingElement
         A polynomial in a ring kk[x] in one variable over a field kk
   Outputs
       alpha:RingElement
         An element in the new ring which is a root of f
   Description
       Text
           Create a field kk[a]/f(a), and return the generator of this new field.
           
           The field kk may be QQ, ZZ/p, GF(p,n), or a field already constructed with adjoinRoot

           If f is linear, a new field is not created.
       Example
           k1 = ZZ/101;
           R = k1[x]
           f = x^3+x+1
           factor f -- f is irreducible
           alpha = adjoinRoot f
       Text
           Over QQ, it uses @TO "toField"@.
       Example
           R = QQ[t]
           F = t^2-3
           b = adjoinRoot(F, Variable=>symbol b)
           1//b
       Text
           kk = ring b
           ambient kk -- nothing useful!
           A = last kk.baseRings
           isField A
           1/A_0
   Caveat
       This doesn't yet work in all situations.  Also, it is not verified that
         f is irreducible
   SeeAlso
       switchCenter
       toField
///

doc ///
    Key
        switchCenter
        (switchCenter,Ring,RingElement)
    Headline
        switch center to a new point
    Usage
        (inc, toNew, toOld) = switchCenter(R, P)
    Inputs
        R:Ring
            a polynomial ring over a field $k$
        P:RingElement
            an irreducible polynomial in R, in one variable
    Outputs
        :Sequence
            A Sequence of three ring maps (inc, toNew, toOld), described below.
    Description
        Text
            A new field $L = k[a]/P(a)$ is constructed (if $P$ has degree one, then $L = k$).
            Then, $S$ is the same polynomial ring as $R$, except the coefficients are now $L$.
            
            The returned ring maps are:
            
             (1) $inc: R = k M \rightarrow L M$, which is defined to be the inclusion on $k \rightarrow L$
             and maps the variables of $R$ to the (same) variables of $S$.
 
            The change of coordinates is done by toNew, fromNew:
                       
            (2) toNew: S --> S, satisfies toNew(x) == x+a
            
            (3) fromNew : S --> S, the inverse map, x --> x-a

        Example
            kk = ZZ/101
            R = kk[x,y]
            Px = x^2+x+1
            F = y^3-x
            (inc, toNew, fromNew) = switchCenter(R, Px)
            G = inc Px
            G1 = toNew G
            G2 = fromNew G1
            -- How to lift back to R?.  What is the best way?
            sub(G2,R)
    Caveat
        Only works with polynomial rings.  Bugs?  Maybe the coeff ring
          being a field is not checked?
    SeeAlso
        adjoinRoot
///

TEST ///
  -- adjoining a root over QQ
  -- once we have a 'toField', frac should return itself and / should just work.
  R = QQ[t]
  F = t^2-3
  b = adjoinRoot(F, Variable=>symbol b)
  kk = ring b
  assert(ring b === frac ring b)
  c = 1/b
  assert(c * b == 1)
  assert(ring c === ring b)
  assert(1//b == c)
  assert(1 % b == 0) -- all remainders like this in a field will be 0
  R = kk[x,y,z]
  G = (x+y+z)^2-3
  --factor G -- BUG: cannot factor!!
///

TEST ///
  -- adjoining a root of a linear polynomial over QQ
  R = QQ[t]
  F = 3*t-7
  b = adjoinRoot(F, Variable=>symbol b)
  kk = ring b
  assert(ring b === frac ring b)
  assert(ring b === QQ)
  c = 1/b
  assert(c * b == 1)
  assert(ring c === ring b)
///

TEST ///
  -- adjoining a root over ZZ/p
  R = ZZ/23[t]
  F = t^2-5
  isPrime F
  b = adjoinRoot(F, Variable=>symbol b) -- creates a Galois Field, but a BigFlint GF.  Is that OK?
  kk = ring b
  assert(ring b === frac ring b)
  c = 1/b
  assert(c * b == 1)
  assert(ring c === ring b)
  assert(1//b == c)
  assert(1 % b == 0) -- all remainders like this in a field will be 0
  -- Now we can use this as a base ring:
  R = kk[x,y,z]
  G = (x^(23^2) - x)
  factor G -- factors into linears
///

TEST ///
  F = conwayPolynomial(23,2)
  kk = coefficientRing ring F
  k1 = ring adjoinRoot F -- is a Flint ring
  R = kk[x]
  -- want the isomorphism between k1 and kk[x]/(x^2-5)
  -- how to get this?  The plan is to find a root of x^2-5 in this field.  Any will do
  R = k1[x]  
  g = first first factor(x^2-5) -- so map x to -4+4a
  b = adjoinRoot g
  phi = map(k1,kk[x]/(x^2-5),{b})
  ker phi
  coimage phi
///

TEST ///
  -- making a tower
  R = QQ[t]
  F = t^2-3
  a = adjoinRoot(F, Variable=>a)
  R1 = (ring a)[t]
  b = adjoinRoot(t^2-a, Variable=>b)
  kk = ring b
  assert(ring b === frac ring b)
  c = 1/b
  assert(c * b == 1)
  assert(ring c === ring b)
  assert(1//b == c)
  assert(1 % b == 0) -- all remainders like this in a field will be 0
  R = kk[x,y,z]
  G = (x+y+z)^2-3
  R2 = (ring b)[t]
  --factor G -- BUG: cannot factor!!
  d = adjoinRoot(a*t-b)
  R2 = (ring b)[t]
  use ring b
  c = adjoinRoot(t^3-a*t-b, Variable=>symbol c)
  ring c
  1/c
  assert((c-3) * 1/(c-3) == 1)
///

///
  -- Given a tower (of irreducible polynomials), make it into a primitive extension (e.g. over ZZ/p or QQ).
  -- Given a tower, factor a polynomial over it (and so determine if it is irreducible).
  restart
  needsPackage "AdjoinRoots"
  debug Core
  R = QQ[c,b,a,MonomialOrder=>Lex]
  L = {a^2-a-1, b^3-b-a, c^2-c-b^3-a}

  A0 = QQ
  B0 = A0[x]
  phi1 = map(B0, R, matrix{{0,0,x}})
  a0 = adjoinRoot(phi1 L#0, Variable => R#generatorSymbols#2)

  A1 = ring a0
  B1 = A1[x]  
  phi2 = map(B1, R, matrix{{0,x,a0}})
  a1 = adjoinRoot(phi2 L#1, Variable => R#generatorSymbols#1)

  A2 = ring a1
  B2 = A2[x]  
  phi3 = map(B2, R, matrix{{x,a1,sub(a0,B2)}})
  a2 = adjoinRoot(phi3 L#2, Variable => R#generatorSymbols#0)

  A = ring a2  
  K = coefficientRing A
  sort basis K

-- Major problem: 'toField' adds in [], and then variables don't work??  

///
end--

restart
uninstallPackage "AdjoinRoots"
restart
loadPackage "AdjoinRoots"

restart
installPackage "AdjoinRoots"
check "AdjoinRoots"
viewHelp "AdjoinRoots"
